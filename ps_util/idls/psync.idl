/**
 * @file core.idl
 * @brief PolySync Data Model Core Module.
 *
 */




// *****************************************************
// PolySync type definitions
// *****************************************************


/**
 * @brief Message identifier type.
 *
 */
typedef unsigned long ps_msg_type;


/**
 * @brief Timestamp type.
 *
 * Typically represents a UTC microsecond value.
 *
 */
typedef unsigned long long ps_timestamp;


/**
 * @brief GUID type.
 *
 * Globally-unique identifier used to identify nodes.
 *
 * Bytes 0:3 are the node identifier.
 * Bytes 4:5 are the node SDF identifier.
 * Bytes 6:7 are the node type.
 *
 */
typedef unsigned long long ps_guid;


/**
 * @brief Diagnostic trouble code type.
 *
 */
typedef unsigned long long ps_dtc;


/**
 * @brief Parameter identifier type.
 *
 */
typedef unsigned long ps_parameter_id;


/**
 * @brief Event identifier type.
 *
 */
typedef unsigned long ps_event_id;


/**
 * @brief Node identifier type.
 *
 * Specifies a generic category for nodes.
 *
 */
typedef unsigned short ps_node_type;


/**
 * @brief Generic identifier type.
 *
 */
typedef unsigned long ps_identifier;


/**
 * @brief Node flags type.
 *
 */
typedef unsigned long ps_node_flags;


/**
 * @brief Record and Replay session identifier type.
 *
 */
typedef unsigned long long ps_rnr_session_id;


/**
 * @brief Interface address value type.
 *
 * Stores an IP address value.
 * "15.5.6.1" would produce 0x0F050601.
 *
 */
typedef unsigned long ps_interface_address;


/**
 * @brief Sensor identifier kind type.
 *
 * Instead of being a normal enum type, valid values are defined
 * by PolySync's sensor support mechanisms.
 *
 */
typedef unsigned long ps_sensor_kind;


/**
 * @brief Command identifier type.
 *
 */
typedef unsigned long long ps_command_id;


/**
 * @brief Parameter group enumeration kind.
 *
 */
typedef unsigned long ps_parameter_group_kind;


/**
 * @brief Parameter group member enumeration kind.
 *
 */
typedef unsigned long ps_parameter_group_member_kind;


/**
 * @brief File sync operation kind.
 *
 */
typedef unsigned long ps_file_sync_operation_kind;




// *****************************************************
// PolySync 'core' module version
// *****************************************************


/**
 * @brief Core module major version. [uint8_t]
 *
 * Indicates a major release version.
 *
 */
const octet CORE_MODULE_VERSION_MAJOR = 2;


/**
 * @brief Core module minor version. [uint8_t]
 *
 * Indicates a minor release version.
 * Increased each time the syntax of the module
 * is changed (ie new or removed messages, new or removed message fields, changed number of bits, etc).
 *
 */
const octet CORE_MODULE_VERSION_MINOR = 1;


/**
 * @brief Core module sub-minor version. [uint16_t]
 *
 * Indicates a sub-minor release version.
 * Increased each time the semantics of the
 * data model are modified (ie interpretation of field values or similar).
 *
 */
const unsigned short CORE_MODULE_VERSION_SUBMINOR = 3;




// *****************************************************
// PolySync constants
// *****************************************************


/**
 * @brief Default PolySync domain identifier.
 *
 * This value can be used when specifying the desired domain
 * a node should participate in (ie when calling function \ref psync_init).
 *
 * When using this value, the domain identifier is determined from the
 * system's configuration environment. This allows changing the domain
 * identifier at runtime on a per-host basis.
 *
 * The default PolySync configuration environment domain identifier is 0.
 *
 */
const unsigned long PSYNC_DEFAULT_DOMAIN = 0x7FFFFFFF;


/**
 * @brief Default PolySync partition name.
 *
 */
const string                    PSYNC_DEFAULT_PARTITION_NAME        = "PSYNCP0";


/**
 * @brief PolySync home environment variable name.
 *
 */
const string                    PSYNC_HOME_ENVIRONMENT_NAME         = "PSYNC_HOME";


/**
 * @brief PolySync system design file name.
 */
const string                    PSYNC_SDF_FILE_NAME                 = "psync.sdf";


/**
 * @brief Size of module verification hash. [bytes]
 *
 */
const unsigned short            PSYNC_MODULE_VERIFY_HASH_LEN        = 16;


/**
 * @brief Default string size used in PolySync. [bytes]
 *
 */
const unsigned short            PSYNC_DEFAULT_STRING_LEN            = 2048;


/**
 * @brief Largest PolySync internal event identifier.
 *
 * @note User event identifiers must be larger than this value.
 *
 * @note Event id values 0:4095 inclusive (bits 0:11) are reserved for PolySync use only.
 */
const ps_event_id               PSYNC_EVENT_ID_MAX                  = 4095;


/**
 * @brief Largest PolySync internal parameter identifier.
 *
 * @note User parameter identifiers must be larger than this value.
 *
 * @note Parameter id values 0:4095 inclusive (bits 0:11) are reserved for PolySync use only.
 */
const ps_parameter_id           PSYNC_PARAMETER_ID_MAX              = 4095;


/**
 * @brief Default publish interval for RnR utilities when recording. [microseconds]
 *
 */
const ps_timestamp              PSYNC_PLOG_RECORD_PUBLISH_INTERVAL  = 500000;


/**
 * @brief Default publish interval for RnR utilities when replaying. [microseconds]
 *
 */
const ps_timestamp              PSYNC_PLOG_REPLAY_PUBLISH_INTERVAL  = 100000;


/**
 * @brief Invalid \ref ps_msg_type value.
 *
 */
const ps_msg_type               PSYNC_MSG_TYPE_INVALID              = 0;


/**
 * @brief Largest message type identifier value.
 *
 */
const ps_msg_type               PSYNC_MSG_TYPE_MAX                  = 0xFFFFFFFF;


/**
 * @brief Invalid \ref ps_interface_address value.
 *
 */
const ps_interface_address      PSYNC_INTERFACE_ADDRESS_INVALID     = 0;


/**
 * @brief Value means interface address is set to 'AUTO'.
 *
 */
const ps_interface_address      PSYNC_INTERFACE_ADDRESS_AUTO        = 0xFFFFFFFF;


/**
 * @brief Invalid \ref ps_sensor_kind value.
 *
 */
const ps_sensor_kind            PSYNC_SENSOR_KIND_INVALID           = 0;


/**
 * @brief Unknown \ref ps_sensor_kind value.
 *
 */
const ps_sensor_kind            PSYNC_SENSOR_KIND_UNKNOWN           = 1;


/**
 * @brief \ref ps_sensor_kind value not available.
 *
 */
const ps_sensor_kind            PSYNC_SENSOR_KIND_NOT_AVAILABLE     = 2;


/**
 * @brief Invalid \ref ps_guid value.
 *
 */
const ps_guid                   PSYNC_GUID_INVALID                  = 0;


/**
 * @brief Invalid \ref ps_rnr_session_id value.
 *
 */
const ps_rnr_session_id         PSYNC_RNR_SESSION_ID_INVALID        = 0;


/**
 * @brief Invalid clock scale value.
 *
 */
const double                    PSYNC_CLOCK_SCALE_INVALID           = -1.0;


/**
 * @brief Maximum file transfer path length.
 *
 */
const unsigned short PSYNC_FILE_TRANSFER_PATH_LENGTH = 512;


/**
 * @brief Maximum file synchroinzation path length.
 *
 */
const unsigned short PSYNC_FILE_SYNC_PATH_LENGTH = 1024;


/**
 * @brief Invalid \ref ps_identifier value.
 *
 */
const ps_identifier             PSYNC_IDENTIFIER_INVALID            = 0;


/**
 * @brief Support for \ref ps_identifer is not available.
 *
 */
const ps_identifier             PSYNC_IDENTIFIER_NOT_AVAILABLE      = 1;


/**
 * @brief Invalid \ref ps_node_type value.
 *
 */
const ps_node_type              PSYNC_NODE_TYPE_INVALID             = 0;


/**
 * @brief \ref ps_node_type value specifies all types.
 *
 */
const ps_node_type              PSYNC_NODE_TYPE_ALL                 = 0xFFFF;


/**
 * @brief PolySync generic API-user node type.
 *
 */
const ps_node_type              PSYNC_NODE_TYPE_API_USER            = 1;


/**
 * @brief PolySync manager node type.
 *
 */
const ps_node_type              PSYNC_NODE_TYPE_MANAGER             = 2;


/**
 * @brief PolySync studio node type.
 *
 */
const ps_node_type              PSYNC_NODE_TYPE_STUDIO              = 3;


/**
 * @brief PolySync studio-plugin node type.
 *
 */
const ps_node_type              PSYNC_NODE_TYPE_STUDIO_PLUGIN       = 4;


/**
 * @brief PolySync simulation-plugin node type.
 *
 */
const ps_node_type              PSYNC_NODE_TYPE_SIMULATION_PLUGIN   = 5;


/**
 * @brief PolySync sensor driver node type.
 *
 */
const ps_node_type              PSYNC_NODE_TYPE_HARDWARE_DRIVER     = 6;


/**
 * @brief PolySync sensor driver node type.
 *
 */
const ps_node_type              PSYNC_NODE_TYPE_SOFTWARE_DRIVER     = 7;


/**
 * @brief PolySync software algorithm node type.
 *
 */
const ps_node_type              PSYNC_NODE_TYPE_SOFTWARE_ALGORITHM  = 8;


/**
 * @brief Invalid PolySync coordinate frame value.
 *
 */
const ps_identifier             PSYNC_COORDINATE_FRAME_INVALID      = 0;


/**
 * @brief Unknown PolySync coordinate frame value.
 *
 */
const ps_identifier             PSYNC_COORDINATE_FRAME_UNKNOWN      = 1;


/**
 * @brief PolySync coordinate frame value not available.
 *
 */
const ps_identifier             PSYNC_COORDINATE_FRAME_NOT_AVAILABLE    = 2;


/**
 * @brief Local coordinate frame.
 *
 * Standard right handed PolySync local coordinate frame.
 *
 */
const ps_identifier             PSYNC_COORDINATE_FRAME_LOCAL        = 3;


/**
 * @brief Platform coordinate frame.
 *
 * Standard right handed PolySync platform coordinate frame.
 * Fixed in the platform body, ie a fixed body coordinate system.
 *
 */
const ps_identifier             PSYNC_COORDINATE_FRAME_PLATFORM     = 4;


/**
 * @brief Relative coordinate frame.
 *
 * Standard right handed PolySync relative coordinate frame.
 * Typically based on a dead-reckoned navigation solution.
 *
 */
const ps_identifier             PSYNC_COORDINATE_FRAME_RELATIVE     = 5;


/**
 * @brief Absolute coordinate frame.
 *
 * Standard right handed PolySync absolute coordinate frame.
 * Typically based on an absolute or world navigation solution like
 * WGS84 UTM coordinate Frame in a given zone.
 *
 */
const ps_identifier             PSYNC_COORDINATE_FRAME_ABSOLUTE     = 6;


/**
 * @brief Parameter flag-bit 0 - parameter is disabled.
 *
 */
const octet PSYNC_PARAMETER_FLAG_DISABLED = 0x01;


/**
 * @brief Parameter flag-bit 1 - parameter is user defined.
 *
 */
const octet PSYNC_PARAMETER_FLAG_USERDEFINED = 0x02;


/**
 * @brief Parameter flag-bit 2 - parameter value is read-only.
 *
 */
const octet PSYNC_PARAMETER_FLAG_READONLY_VALUE = 0x04;


/**
 * @brief Parameter flag-bit 3 - parameter range minimum value is read-only.
 *
 */
const octet PSYNC_PARAMETER_FLAG_READONLY_MIN = 0x08;


/**
 * @brief Parameter flag-bit 4 - parameter range maximum value is read-only.
 *
 */
const octet PSYNC_PARAMETER_FLAG_READONLY_MAX = 0x10;


/**
 * @brief Parameter flag-bit 5 - parameter range step value is read-only.
 *
 */
const octet PSYNC_PARAMETER_FLAG_READONLY_STEP = 0x20;


/**
 * @brief Parameter flag-bit 6 - parameter is part of the analytics set.
 *
 */
const octet PSYNC_PARAMETER_FLAG_ANALYTIC = 0x40;


/**
 * @brief Invalid native timestamp format.
 *
 */
const octet PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID = 0;


/**
 * @brief Unknown native timestamp format.
 *
 */
const octet PSYNC_NATIVE_TIMESTAMP_FORMAT_UNKNOWN = 1;


/**
 * @brief Native timestamp format not available.
 *
 */
const octet PSYNC_NATIVE_TIMESTAMP_FORMAT_NOT_AVAILABLE = 2;


/**
 * @brief Relative milliseconds since power-up.
 *
 */
const octet PSYNC_NATIVE_TIMESTAMP_FORMAT_RELATIVE_MILLI = 3;


/**
 * @brief Relative microseconds since power-up.
 *
 */
const octet PSYNC_NATIVE_TIMESTAMP_FORMAT_RELATIVE_MICRO = 4;


/**
 * @brief Absolute NTP timestamp.
 *
 * NTP64 timestamps represent the time encoded in 8 bytes. In order to decode NTP64
 * timestamps, the corresponding 8 bytes need to be interpreted as UINT64:
 * The higher 4 bytes are the number of seconds since 1.1.1900 - 0:00:00. The lower 4
 * bytes represent the fractional seconds with a resolution of 2-32 s.
 *
 */
const octet PSYNC_NATIVE_TIMESTAMP_FORMAT_ABSOLUTE_NTP64 = 5;


/**
 * @brief Relative nanoseconds since power-up.
 *
 */
const octet PSYNC_NATIVE_TIMESTAMP_FORMAT_RELATIVE_NANO = 6;


/**
 * @brief Absolute GPS time since the start of the GPS epoch 1980
 * expressed in nanoseconds.
 *
 */
const octet PSYNC_NATIVE_TIMESTAMP_FORMAT_ABSOLUTE_GPS_NANO = 7;




// *****************************************************
// PolySync core command identifiers
// *****************************************************

/**
 * @brief Largest PolySync internal command identifier.
 *
 */
const ps_command_id PSYNC_COMMAND_ID_MAX = 65535;


/**
 * @brief Invalid \ref ps_command_id value.
 *
 * Reserved command identifier.
 *
 */
const ps_command_id PSYNC_COMMAND_ID_INVALID = 0;


/**
 * @brief Get Manager node status command identifier.
 *
 * Command Data: NA
 *
 * Response:
 * \li Message type: \ref ps_manager_status_msg
 * \li Contains manager node status and the status of its runtime nodes
 * \li Message type: \ref ps_response_msg
 *
 * Response Data: NA
 *
 */
const ps_command_id PSYNC_COMMAND_GET_MANAGER_STATUS = 100;


/**
 * @brief Enable Manager node replay mode command identifier.
 *
 * Command Data: NA
 *
 * Response:
 * \li Message type: \ref ps_manager_status_msg
 * \li Contains manager node status and the status of its runtime nodes
 * \li Message type: \ref ps_response_msg
 *
 * Response Data: NA
 *
 */
const ps_command_id PSYNC_COMMAND_ENABLE_MANAGER_REPLAY_MODE = 101;


/**
 * @brief Enable Manager node record mode command identifier.
 *
 * Command Data: NA
 *
 * Response:
 * \li Message type: \ref ps_manager_status_msg
 * \li Contains manager node status and the status of its runtime nodes
 * \li Message type: \ref ps_response_msg
 *
 * Response Data: NA
 *
 */
const ps_command_id PSYNC_COMMAND_ENABLE_MANAGER_RECORD_MODE = 102;


/**
 * @brief Disable Manager node runtime nodes command identifier.
 *
 * Command Data: NA
 *
 * Response:
 * \li Message type: \ref ps_manager_status_msg
 * \li Contains manager node status and the status of its runtime nodes
 * \li Message type: \ref ps_response_msg
 *
 * Response Data: NA
 *
 */
const ps_command_id PSYNC_COMMAND_DISABLE_MANAGER_NODES = 103;


/**
 * @brief Restart Manager node command identifier.
 *
 * Command Data: NA
 *
 * Response:
 * \li Message type: \ref ps_manager_status_msg
 * \li Contains manager node status and the status of its runtime nodes
 * \li Message type: \ref ps_response_msg
 *
 * Response Data: NA
 *
 */
const ps_command_id PSYNC_COMMAND_RESTART_MANAGER = 104;


/**
 * @brief Force Manager re-synchronization command identifier.
 *
 * Forcefully re-synchronize the RnR clock resources.
 *
 * @warning All nodes should killed before this command is executed.
 *
 * Command Data: NA
 *
 * Response:
 * \li Message type: \ref ps_manager_status_msg
 * \li Contains manager node status and the status of its runtime nodes
 * \li Message type: \ref ps_response_msg
 *
 * Response Data: NA
 *
 */
const ps_command_id PSYNC_COMMAND_FORCE_MANAGER_SYNC = 105;


/**
 * @brief Set the runtime SDF configuration primary key command identifier.
 *
 * Command Data:
 * \li Expects data element zero to be type unsigned long long - \ref PSYNC_SDF_ID_INVALID is invalid
 *
 * Response:
 * \li Message type: \ref ps_manager_status_msg
 * \li Contains manager node status and the status of its runtime nodes
 * \li Message type: \ref ps_response_msg
 *
 * Response Data: NA
 *
 */
const ps_command_id PSYNC_COMMAND_SET_MANAGER_RUNTIME_KEY = 106;


/**
 * @brief Set the SDF path used by the PolySync Manager and the nodes it manages.
 *
 * This setting will only persist for the life-cycle of the manager node.
 *
 * Command Data:
 * \li Expects data element zero to be a fully qualified path with type string.
 * \li A NULL string buffer/length means to reset to the default SDF path.
 *
 * Response:
 * \li Message type: \ref ps_manager_status_msg
 * \li Message type: \ref ps_response_msg
 *
 * Response Data: NA
 *
 */
const ps_command_id PSYNC_COMMAND_SET_MANAGER_SDF_PATH = 107;


/**
 * @brief Get the SDF path used by the PolySync Manager and the nodes it manages.
 *
 * Command Data: NA
 *
 * Response:
 * \li Message type: \ref ps_response_msg
 *
 * Response Data:
 * \li Data element zero will be a fully qualified path with type string.
 *
 */
const ps_command_id PSYNC_COMMAND_GET_MANAGER_SDF_PATH = 108;


/**
 * @brief Get the RnR logs path used by the PolySync Manager and the nodes it manages.
 *
 * Command Data: NA
 *
 * Response:
 * \li Message type: \ref ps_response_msg
 *
 * Response Data:
 * \li Data element zero will be a fully qualified path with type string.
 *
 */
const ps_command_id PSYNC_COMMAND_GET_MANAGER_RNR_PATH = 109;


/**
 * @brief Get the PSYNC_USER_HOME path used by the PolySync Manager and the nodes it manages.
 *
 * Command Data: NA
 *
 * Response:
 * \li Message type: \ref ps_response_msg
 *
 * Response Data:
 * \li Data element zero will be a fully qualified path with type string.
 *
 */
const ps_command_id PSYNC_COMMAND_GET_MANAGER_USER_HOME = 110;




// *****************************************************
// PolySync core diagnostic trouble codes
// *****************************************************


/**
 * @brief No error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NONE                            = 0;


/**
 * @brief Usage error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_USAGE                           = 20;


/**
 * @brief System design file not accessible.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NOSDF                           = 40;


/**
 * @brief System design file corrupt.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_BADSDF                          = 41;


/**
 * @brief System design file key invalid.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_SDFKEY                          = 42;


/**
 * @brief Data model configuration error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_PDMCONFIG                       = 50;


/**
 * @brief Data model 'core' module version is not supported by the API version.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_PDMCORE_VERSION                 = 51;


/**
 * @brief Interrupted system call error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_INTR                            = 70;


/**
 * @brief Operation in progress error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_INPROGRESS                      = 75;


/**
 * @brief Data format error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_DATAERR                         = 100;


/**
 * @brief Cannot open input.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NOINPUT                         = 102;


/**
 * @brief Addressee unknown.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NOUSER                          = 103;


/**
 * @brief Host name unknown.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NOHOST                          = 104;


/**
 * @brief Service unavailable.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_UNAVAILABLE                     = 105;


/**
 * @brief System error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_OSERR                           = 106;


/**
 * @brief Memory error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_MEMERR                          = 107;


/**
 * @brief Critical OS file missing.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_OSFILE                          = 108;


/**
 * @brief Can't create output file.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_CANTCREAT                       = 109;


/**
 * @brief Input/output error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_IOERR                           = 110;


/**
 * @brief Error in protocol.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_PROTOCOL                        = 111;


/**
 * @brief Permission denied.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NOPERM                          = 112;


/**
 * @brief Configuration error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_CONFIG                          = 113;


/**
 * @brief Runtime environment error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_ENVERR                          = 114;


/**
 * @brief License error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_LICERR                          = 115;


/**
 * @brief Message/resource type is not supported.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_TYPESUPPORT                     = 116;


/**
 * @brief Bad device initialization.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_BADDEVICEINIT                   = 300;


/**
 * @brief No device initialization.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NODEVICEINIT                    = 301;


/**
 * @brief Device not powered.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NODEVICEPWR                     = 302;


/**
 * @brief Device damaged.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_DEVICEDAMAGED                   = 303;


/**
 * @brief Interface not connected.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NOINTERFACE                     = 304;


/**
 * @brief Interface protocol violated.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_INTERFACEPROTOCOL               = 305;


/**
 * @brief Interface saturated.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_INTERFACESATURATED              = 306;


/**
 * @brief Interface in use.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_INTERFACEINUSE                  = 307;


/**
 * @brief Native bus not connected.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NONATIVEBUS                     = 308;


/**
 * @brief Native bus protocol violated.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NATIVEBUSPROTOCOL               = 309;


/**
 * @brief Native bus saturated.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NATIVEBUSSATURATED              = 310;


/**
 * @brief Native bus in use.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc                    DTC_NATIVEBUSINUSE                  = 311;




// *****************************************************
// PolySync core parameter identifiers
// *****************************************************

/**
 * @brief Invalid \ref ps_parameter.id value.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_INVALID = 0;


/**
 * @brief Special \ref ps_parameter.id value used to specify all parameters supported by the receiver.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: NA
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_ALL = 1;


/**
 * @brief PolySync API version data.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_version encoded as a unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_API_VERSION_DATA = 10;


/**
 * @brief PolySync data model 'core' module version data.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_version encoded as a unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CORE_VERSION_DATA = 11;


/**
 * @brief Static backward time offset.
 *
 * The static time offset to subtract system time by.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_timestamp
 * \li units: microseconds
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_STATIC_BACKWARDTIME_OFFSET = 20;


/**
 * @brief Static forward time offset.
 *
 * The static time offset to add to system time.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_timestamp
 * \li units: microseconds
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_STATIC_FORWARDTIME_OFFSET = 21;


/**
 * @brief Executable file path.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_EX_FILE_PATH = 40;


/**
 * @brief Executable command-line arguments.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_EX_OPT_ARGS = 41;


/**
 * @brief PolySync-Abstraction-Layer interface file Name.
 *
 * Identifies the PAL file used by the dynamic-driver application.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_PAL_IFACE_FILE = 42;


/**
 * @brief SDF CSV key list 0.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SDF_CSV_KEYLIST_0 = 50;


/**
 * @brief SDF CSV key list description 0.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SDF_CSV_KEYLIST_DESC_0 = 51;


/**
 * @brief SDF CSV key list 1.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SDF_CSV_KEYLIST_1 = 52;


/**
 * @brief SDF CSV key list description 1.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SDF_CSV_KEYLIST_DESC_1 = 53;


/**
 * @brief Third party software key 0.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SW_KEY_0 = 80;


/**
 * @brief Third party software key description 0.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SW_KEY_DESC_0 = 81;


/**
 * @brief Third party software key 1.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SW_KEY_1 = 82;


/**
 * @brief Third party software key description 1.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SW_KEY_DESC_1 = 83;


/**
 * @brief Host PolySync network interface address.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid 'X.X.X.X' address or 'AUTO'.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_HOST_IP_ADDRESS = 110;


/**
 * @brief Host CPU count.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_HOST_CPU_COUNT = 111;


/**
 * @brief Average host CPU load.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: normalized
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_HOST_CPU_LOAD = 112;


/**
 * @brief CAN channel 0 hardware identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN0_HW_ID = 400;


/**
 * @brief CAN channel 0 circuit identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN0_CC_ID = 401;


/**
 * @brief CAN channel 0 system identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN0_SYS_ID = 402;


/**
 * @brief CAN channel 0 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN0_DATARATE = 403;


/**
 * @brief CAN channel 0 bus on/off state.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: boolean
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN0_ONBUS_STATE = 404;


/**
 * @brief CAN channel 1 hardware identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN1_HW_ID = 405;


/**
 * @brief CAN channel 1 circuit identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN1_CC_ID = 406;


/**
 * @brief CAN channel 1 system identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN1_SYS_ID = 407;


/**
 * @brief CAN channel 1 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN1_DATARATE = 408;


/**
 * @brief CAN channel 1 bus on/off state.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: boolean
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN1_ONBUS_STATE = 409;


/**
 * @brief CAN channel 2 hardware identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN2_HW_ID = 410;


/**
 * @brief CAN channel 2 circuit identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN2_CC_ID = 411;


/**
 * @brief CAN channel 2 system identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN2_SYS_ID = 412;


/**
 * @brief CAN channel 2 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN2_DATARATE = 413;


/**
 * @brief CAN channel 2 bus on/off state.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: boolean
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN2_ONBUS_STATE = 414;


/**
 * @brief CAN channel 3 hardware identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN3_HW_ID = 415;


/**
 * @brief CAN channel 3 circuit identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN3_CC_ID = 416;


/**
 * @brief CAN channel 3 system identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN3_SYS_ID = 417;


/**
 * @brief CAN channel 3 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN3_DATARATE = 418;


/**
 * @brief CAN channel 3 bus on/off state.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: boolean
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN3_ONBUS_STATE = 419;


/**
 * @brief CAN channel 4 hardware identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN4_HW_ID = 420;


/**
 * @brief CAN channel 4 circuit identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN4_CC_ID = 421;


/**
 * @brief CAN channel 4 system identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN4_SYS_ID = 422;


/**
 * @brief CAN channel 4 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN4_DATARATE = 423;


/**
 * @brief CAN channel 4 bus on/off state.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: boolean
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN4_ONBUS_STATE = 424;


/**
 * @brief CAN channel 5 hardware identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN5_HW_ID = 425;


/**
 * @brief CAN channel 5 circuit identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN5_CC_ID = 426;


/**
 * @brief CAN channel 5 system identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN5_SYS_ID = 427;


/**
 * @brief CAN channel 5 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN5_DATARATE = 428;


/**
 * @brief CAN channel 5 bus on/off state.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: boolean
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_CAN5_ONBUS_STATE = 429;


/**
 * @brief Socket 0 port number.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET0_PORT = 500;


/**
 * @brief Socket 0 address.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid 'X.X.X.X' address.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET0_ADDRESS = 501;


/**
 * @brief Socket 1 port number.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET1_PORT = 502;


/**
 * @brief Socket 1 address.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid 'X.X.X.X' address.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET1_ADDRESS = 503;


/**
 * @brief Socket 2 port number.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET2_PORT = 504;


/**
 * @brief Socket 2 address.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid 'X.X.X.X' address.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET2_ADDRESS = 505;


/**
 * @brief Socket 3 port number.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET3_PORT = 506;


/**
 * @brief Socket 3 address.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid 'X.X.X.X' address.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET3_ADDRESS = 507;


/**
 * @brief Socket 4 port number.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET4_PORT = 508;


/**
 * @brief Socket 4 address.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid 'X.X.X.X' address.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET4_ADDRESS = 509;


/**
 * @brief Socket 5 port number.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET5_PORT = 510;


/**
 * @brief Socket 5 address.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid 'X.X.X.X' address.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SOCKET5_ADDRESS = 511;


/**
 * @brief Serial device 0 name.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid '/dev/tty*' name.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL0_NAME = 600;


/**
 * @brief Serial device 0 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL0_DATARATE = 601;


/**
 * @brief Serial device 1 name.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid '/dev/tty*' name.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL1_NAME = 602;


/**
 * @brief Serial device 1 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL1_DATARATE = 603;


/**
 * @brief Serial device 2 name.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid '/dev/tty*' name.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL2_NAME = 604;


/**
 * @brief Serial device 2 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL2_DATARATE = 605;


/**
 * @brief Serial device 3 name.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid '/dev/tty*' name.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL3_NAME = 606;


/**
 * @brief Serial device 3 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL3_DATARATE = 607;


/**
 * @brief Serial device 4 name.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid '/dev/tty*' name.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL4_NAME = 608;


/**
 * @brief Serial device 4 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL4_DATARATE = 609;


/**
 * @brief Serial device 5 name.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid '/dev/tty*' name.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL5_NAME = 610;


/**
 * @brief Serial device 5 datarate.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_datarate_kind
 * \li units: *bits/second
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SERIAL5_DATARATE = 611;


/**
 * @brief Active coordinate frame identifier.
 *
 * Used to get/set the active parent coordinate frame identifier, usually at
 * the node level.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_identifier
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_COORDINATE_FRAME = 800;


/**
 * @brief Output field of view range.
 *
 * Output field of view clipping, usually at the node level.
 *
 * Value is used to indicate the range and inclusive/exclusive properties for the given FOV settings.
 *
 * If value is zero or positive, FOV includes data starting from min angle to max angle, moving counter-clockwise.
 * If value is negative, FOV includes data starting from min angle to max angle, moving clockwise.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double range {min,max,NA}
 * \li units: radians, radians, NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_OUTPUT_FOV = 810;


/**
 * @brief GPS antenna 0 X position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_GPS0_ANTENNA_MOUNT_X = 900;


/**
 * @brief GPS antenna 0 Y position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_GPS0_ANTENNA_MOUNT_Y = 901;


/**
 * @brief GPS antenna 0 Z position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_GPS0_ANTENNA_MOUNT_Z = 902;


/**
 * @brief GPS antenna 1 X position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_GPS1_ANTENNA_MOUNT_X = 903;


/**
 * @brief GPS antenna 1 Y position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_GPS1_ANTENNA_MOUNT_Y = 904;


/**
 * @brief GPS antenna 1 Z position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_GPS1_ANTENNA_MOUNT_Z = 905;


/**
 * @brief GPS antenna 2 X position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_GPS2_ANTENNA_MOUNT_X = 906;


/**
 * @brief GPS antenna 2 Y position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_GPS2_ANTENNA_MOUNT_Y = 907;


/**
 * @brief GPS antenna 2 Z position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_GPS2_ANTENNA_MOUNT_Z = 908;


/**
 * @brief Sensor 0 PolySync type identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_sensor_kind
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR0_TYPE = 1000;


/**
 * @brief Sensor 0 identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_identifier
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR0_ID = 1001;


/**
 * @brief Sensor 0 X position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR0_MOUNT_X  = 1002;


/**
 * @brief Sensor 0 Y position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR0_MOUNT_Y  = 1003;


/**
 * @brief Sensor 0 Z position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR0_MOUNT_Z  = 1004;


/**
 * @brief Sensor 0 roll orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR0_MOUNT_ROLL  = 1005;


/**
 * @brief Sensor 0 pitch orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR0_MOUNT_PITCH  = 1006;


/**
 * @brief Sensor 0 yaw orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR0_MOUNT_YAW  = 1007;


/**
 * @brief Sensor 1 PolySync type identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_sensor_kind
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR1_TYPE = 1008;


/**
 * @brief Sensor 1 identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_identifier
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR1_ID = 1009;


/**
 * @brief Sensor 1 X position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR1_MOUNT_X = 1010;


/**
 * @brief Sensor 1 Y position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR1_MOUNT_Y = 1011;


/**
 * @brief Sensor 1 Z position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR1_MOUNT_Z = 1012;


/**
 * @brief Sensor 1 roll orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR1_MOUNT_ROLL = 1013;


/**
 * @brief Sensor 1 pitch orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR1_MOUNT_PITCH = 1014;


/**
 * @brief Sensor 1 yaw orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR1_MOUNT_YAW = 1015;


/**
 * @brief Sensor 2 PolySync type identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_sensor_kind
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR2_TYPE = 1016;


/**
 * @brief Sensor 2 identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_identifier
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR2_ID = 1017;


/**
 * @brief Sensor 2 X position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR2_MOUNT_X = 1018;


/**
 * @brief Sensor 2 Y position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR2_MOUNT_Y = 1019;


/**
 * @brief Sensor 2 Z position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR2_MOUNT_Z = 1020;


/**
 * @brief Sensor 2 roll orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR2_MOUNT_ROLL = 1021;


/**
 * @brief Sensor 2 pitch orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR2_MOUNT_PITCH = 1022;


/**
 * @brief Sensor 2 yaw orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR2_MOUNT_YAW = 1023;


/**
 * @brief Sensor 3 PolySync type identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_sensor_kind
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR3_TYPE = 1024;


/**
 * @brief Sensor 3 identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_identifier
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR3_ID = 1025;


/**
 * @brief Sensor 3 X position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR3_MOUNT_X = 1026;


/**
 * @brief Sensor 3 Y position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR3_MOUNT_Y = 1027;


/**
 * @brief Sensor 3 Z position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR3_MOUNT_Z = 1028;


/**
 * @brief Sensor 3 roll orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR3_MOUNT_ROLL = 1029;


/**
 * @brief Sensor 3 pitch orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR3_MOUNT_PITCH = 1030;


/**
 * @brief Sensor 3 yaw orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR3_MOUNT_YAW = 1031;


/**
 * @brief Sensor 4 PolySync type identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_sensor_kind
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR4_TYPE = 1032;


/**
 * @brief Sensor 4 identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_identifier
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR4_ID = 1033;


/**
 * @brief Sensor 4 X position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR4_MOUNT_X = 1034;


/**
 * @brief Sensor 4 Y position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR4_MOUNT_Y = 1035;


/**
 * @brief Sensor 4 Z position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR4_MOUNT_Z = 1036;


/**
 * @brief Sensor 4 roll orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR4_MOUNT_ROLL = 1037;


/**
 * @brief Sensor 4 pitch orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR4_MOUNT_PITCH = 1038;


/**
 * @brief Sensor 4 yaw orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR4_MOUNT_YAW = 1039;


/**
 * @brief Sensor 5 PolySync type identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_sensor_kind
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR5_TYPE = 1040;


/**
 * @brief Sensor 5 identifier.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_identifier
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR5_ID = 1041;


/**
 * @brief Sensor 5 X position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR5_MOUNT_X = 1042;


/**
 * @brief Sensor 5 Y position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR5_MOUNT_Y = 1043;


/**
 * @brief Sensor 5 Z position.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR5_MOUNT_Z = 1044;


/**
 * @brief Sensor 5 roll orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR5_MOUNT_ROLL = 1045;


/**
 * @brief Sensor 5 pitch orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR5_MOUNT_PITCH = 1046;


/**
 * @brief Sensor 5 yaw orientation.
 *
 * Relative to the platform frame.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_SENSOR5_MOUNT_YAW = 1047;


/**
 * @brief Video device 0 name.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Valid '/dev/video*' name.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_NAME = 1080;


/**
 * @brief Video device 0 type.
 *
 * \li value type: \ref PARAMETER_VALUE_STRING
 * \li type: string
 * \li units: Device type string.
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_TYPE = 1081;


/**
 * @brief Video device 0 source pixel format.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_pixel_format_kind encoded as a unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_FORMAT = 1082;


/**
 * @brief Video device 0 source image width.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_WIDTH = 1083;


/**
 * @brief Video device 0 source image height.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_HEIGHT = 1084;


/**
 * @brief Video device 0 source image frames per second.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: FPS
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_FPS = 1085;


/**
 * @brief Video device 0 source image X offset.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_XOFFSET = 1086;


/**
 * @brief Video device 0 source image Y offset.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_YOFFSET = 1087;


/**
 * @brief Video device 0 published pixel format.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_pixel_format_kind encoded as a unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_PUBLISHED_FORMAT = 1088;


/**
 * @brief Video device 0 published image width.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_PUBLISHED_WIDTH = 1089;


/**
 * @brief Video device 0 published image height.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_PUBLISHED_HEIGHT = 1090;


/**
 * @brief Video device 0 published image frames per second.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: FPS
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_PUBLISHED_FPS = 1091;


/**
 * @brief Video device 0 logged pixel format.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_pixel_format_kind encoded as a unsigned long long
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_LOGGED_FORMAT = 1092;


/**
 * @brief Video device 0 logged image width.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_LOGGED_WIDTH = 1093;


/**
 * @brief Video device 0 logged image height.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_LOGGED_HEIGHT = 1094;


/**
 * @brief Video device 0 horizontal focal length.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_KU = 1095;


/**
 * @brief Video device 0 vertical focal length.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_KV = 1096;


/**
 * @brief Video device 0 horizontal optical center.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_U0 = 1097;


/**
 * @brief Video device 0 vertical optical center.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: pixels
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_V0 = 1098;


/**
 * @brief Video device 0 focal length.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: meters
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_FOCAL_LENGTH = 1099;


/**
 * @brief Video device 0 horizontal image flip flag.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: boolean
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_HORIZONTAL_FLIP = 1100;


/**
 * @brief Video device 0 vertical image flip flag.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: boolean
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_VERTICAL_FLIP = 1101;


/**
 * @brief Video device 0 2x2 image binning enabled flag.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: unsigned long long
 * \li units: boolean
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_2X2_BINNING = 1102;


/**
 * @brief Video device 0 shared memory output queue key.
 *
 * Used to create a shared memory queue on the host for accessing video data.
 *
 * @note Value \ref PSYNC_IDENTIFIER_INVALID means shared memory queue not used.
 *
 * \li value type: \ref PARAMETER_VALUE_ULONGLONG
 * \li type: \ref ps_identifier
 * \li units: NA
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_SHARED_MEM_QUEUE_KEY = 1103;


/**
 * @brief Video device 0 horizontal field of view angle.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_HORIZONTAL_FOV = 1104;


/**
 * @brief Video device 0 vertical field of view angle.
 *
 * \li value type: \ref PARAMETER_VALUE_DOUBLE
 * \li type: double
 * \li units: radians
 *
 * Reserved parameter ID.
 *
 */
const ps_parameter_id PSYNC_PARAM_ID_VIDEO0_VERTICAL_FOV = 1105;




// *****************************************************
// PolySync core parameter groups
// *****************************************************


/**
 * @brief Invalid kind of a parameter group member.
 *
 */
const ps_parameter_group_member_kind PSYNC_PARAMETER_GROUP_MEMBER_INVALID = 0;


/**
 * @brief Invalid ordering of a parameter group member.
 *
 * @note Not all groups require valid member orders to reliably store
 * and retrieve parameter group members.
 *
 */
const unsigned long PSYNC_PARAMETER_GROUP_MEMBER_ORDER_INVALID = 0;


/**
 * @brief Invalid kind of parameter group.
 *
 */
const ps_parameter_group_kind PSYNC_PARAMETER_GROUP_INVALID = 0;


/**
 * @brief Generic parameter group format kind.
 *
 * @note Represented via \ref ps_parameter_group_generic.
 *
 * Operations which require a consistently iteratable container
 * may convert specialized parameter groups to the generic format
 * via \ref psync_parameter_group_to_generic from
 * "polysync_parameter_group.h".
 *
 */
const ps_parameter_group_kind PSYNC_PARAMETER_GROUP_GENERIC = 1;


/**
 * @brief A kind of parameter group with a list of associated parameters.
 *
 * @note Represented via \ref ps_parameter_group_list.
 * @note Visually represented via a collapsible section.
 *
 */
const ps_parameter_group_kind PSYNC_PARAMETER_GROUP_LIST = 2;


/**
 * @brief A kind of parameter group with a list of \ref ps_parameter_group_list_item.
 *
 * @note Represented via \ref ps_parameter_group_option_list.
 * @note Visually represented via a dropdown selection.
 *
 * The list items are pairs of user facing string labels
 * and the literal value they represent. When an option is selected,
 * the value parameter should be set to the value chosen.
 *
 */
const ps_parameter_group_kind PSYNC_PARAMETER_GROUP_OPTION_LIST = 3;


/**
 * @brief A kind of parameter group with two parameters comprising a value range.
 *
 * @note Represented via \ref ps_parameter_group_value_range.
 *
 */
const ps_parameter_group_kind PSYNC_PARAMETER_GROUP_VALUE_RANGE = 4;


/**
 * @brief A kind of parameter group with two parameters comprising a value range,
 * with the two parameters having min/max values which bound possible values.
 *
 * @note Represented via \ref ps_parameter_group_value_range.
 *
 */
const ps_parameter_group_kind PSYNC_PARAMETER_GROUP_VALUE_RANGE_BOUNDED = 5;


/**
 * @brief A kind of parameter group only a single member.
 *
 * @note Used in cases where it is necessary to generically represent all parameters
 * as members of groups. In such cases, it is convenient to treat a solo parameter
 * as the only member of its own individual group.
 *
 */
const ps_parameter_group_kind PSYNC_PARAMETER_GROUP_INDIVIDUAL = 6;


/**
 * @brief Range bounding of valid, core parameter groups.
 *
 */
const ps_parameter_group_kind PSYNC_PARAMETER_GROUP_KIND_COUNT = 7;


/**
 * @brief An invalid kind of file synchronization operation.
 *
 */
const ps_file_sync_operation_kind PSYNC_FILE_SYNC_OPERATION_INVALID = 0;


/**
 * @brief An error occurred during the file synchronization operation.
 *
 */
const ps_file_sync_operation_kind PSYNC_FILE_SYNC_OPERATION_ERROR = 1;


/**
 * @brief A request to send a file via synchronization.
 *
 */
const ps_file_sync_operation_kind PSYNC_FILE_SYNC_OPERATION_REQUEST = 2;


/**
 * @brief A request to send a file via synchronization.
 *
 */
const ps_file_sync_operation_kind PSYNC_FILE_SYNC_OPERATION_SEND = 3;


/**
 * @brief A request to receive a file via synchronization.
 *
 */
const ps_file_sync_operation_kind PSYNC_FILE_SYNC_OPERATION_RECEIVE = 4;


/**
 * @brief A request to receive a file via local copy.
 *
 * Useful if node's detect they are on same host and thus may avoid using the network.
 *
 */
const ps_file_sync_operation_kind PSYNC_FILE_SYNC_OPERATION_LOCAL_COPY = 5;


/**
 * @brief A request to complete a file synchronization.
 *
 */
const ps_file_sync_operation_kind PSYNC_FILE_SYNC_OPERATION_COMPLETE = 6;


/**
 * @brief The count of ps_file_sync_operation_kind.
 *
 */
const ps_file_sync_operation_kind PSYNC_FILE_SYNC_OPERATION_KIND_COUNT = 7;




// *****************************************************
// PolySync enumerated types
// *****************************************************


/**
 * @brief Log level kinds.
 *
 */
enum ps_log_level_kind
{
    //
    //
    LOG_LEVEL_DEBUG, /*!< Log with debug level. */
    //
    //
    LOG_LEVEL_INFO, /*!< Log with informative level. */
    //
    //
    LOG_LEVEL_WARN, /*!< Log with warning level. */
    //
    //
    LOG_LEVEL_ERROR, /*!< Log with error level. */
    //
    //
    LOG_LEVEL_KIND_COUNT /*!< Number of \ref ps_log_level_kind values. */
};


/**
 * @brief Datarate kinds.
 *
 */
enum ps_datarate_kind
{
    //
    //
    DATARATE_INVALID, /*!< Invalid datarate kind. */
    //
    //
    DATARATE_UNKNOWN, /*!< Unknown datarate kind. */
    //
    //
    DATARATE_NA, /*!< Datarate kind not available. */
    //
    //
    DATARATE_1200, /*!< 1200 bit/s. */
    //
    //
    DATARATE_1800, /*!< 1800 bit/s. */
    //
    //
    DATARATE_2400, /*!< 2400 bit/s. */
    //
    //
    DATARATE_4800, /*!< 4800 bit/s. */
    //
    //
    DATARATE_9600, /*!< 9600 bit/s. */
    //
    //
    DATARATE_19200, /*!< 19200 bit/s. */
    //
    //
    DATARATE_38400, /*!< 38400 bit/s. */
    //
    //
    DATARATE_57600, /*!< 57600 bit/s. */
    //
    //
    DATARATE_115200, /*!< 115200 bit/s. */
    //
    //
    DATARATE_230400, /*!< 230400 bit/s. */
    //
    //
    DATARATE_100K, /*!< 100 kbit/s. */
    //
    //
    DATARATE_125K, /*!< 125 kbit/s. */
    //
    //
    DATARATE_250K, /*!< 250 kbit/s. */
    //
    //
    DATARATE_500K, /*!< 500 kbit/s. */
    //
    //
    DATARATE_1M, /*!< 1 Mbit/s. */
    //
    //
    DATARATE_KIND_COUNT /*!< Number of \ref ps_datarate_kind values. */
};


/**
 * @brief Network interface kinds.
 *
 */
enum ps_network_interface_kind
{
    //
    //
    NETWORK_INTERFACE_INVALID, /*!< Invalid network interface kind. */
    //
    //
    NETWORK_INTERFACE_UNKNOWN, /*!< Unknown network interface kind. */
    //
    //
    NETWORK_INTERFACE_NOT_AVAILABLE, /*!< Network interface kind not available. */
    //
    //
    NETWORK_INTERFACE_AUTO, /*!< Interface is set to "AUTO". */
    //
    //
    NETWORK_INTERFACE_LO, /*!< Loop-back interface. */
    //
    //
    NETWORK_INTERFACE_WLAN0, /*!< Wireless interface 0. */
    //
    //
    NETWORK_INTERFACE_WLAN1, /*!< Wireless interface 1. */
    //
    //
    NETWORK_INTERFACE_WLAN2, /*!< Wireless interface 2. */
    //
    //
    NETWORK_INTERFACE_WLAN3, /*!< Wireless interface 3. */
    //
    //
    NETWORK_INTERFACE_ETH0, /*!< Ethernet interface 0. */
    //
    //
    NETWORK_INTERFACE_ETH1, /*!< Ethernet interface 1. */
    //
    //
    NETWORK_INTERFACE_ETH2, /*!< Ethernet interface 2. */
    //
    //
    NETWORK_INTERFACE_ETH3, /*!< Ethernet interface 3. */
    //
    //
    NETWORK_INTERFACE_ETH4, /*!< Ethernet interface 4. */
    //
    //
    NETWORK_INTERFACE_ETH5, /*!< Ethernet interface 5. */
    //
    //
    NETWORK_INTERFACE_ETH6, /*!< Ethernet interface 6. */
    //
    //
    NETWORK_INTERFACE_ETH7, /*!< Ethernet interface 7. */
    //
    //
    NETWORK_INTERFACE_ETH8, /*!< Ethernet interface 8. */
    //
    //
    NETWORK_INTERFACE_ETH9, /*!< Ethernet interface 9. */
    //
    //
    NETWORK_INTERFACE_KIND_COUNT /*!< Number of \ref ps_network_interface_kind values. */
};


/**
 * @brief Record and Replay message kinds.
 *
 * Valid values for \ref ps_rnr_msg.type field.
 * Some types will use the \ref ps_rnr_msg.control_data field for additional data.
 * Unknown types will be ignored where as invalid types could be handled as errors.
 *
 */
enum ps_rnr_msg_kind
{
    //
    //
    RNR_MSG_INVALID, /*!< Invalid RnR message kind. */
    //
    //
    RNR_MSG_UNKNOWN, /*!< Unknown RnR message kind. */
    //
    //
    RNR_MSG_STATUS, /*!< Status of producer's RnR utilities.
                     * All common fields of the \ref ps_rnr_msg are filled by the producer, and reflect it's logfile data.
                     * Does not use the \ref ps_rnr_msg.control_data field. */
    //
    //
    RNR_MSG_REPLAY_SYNC_TIME_SET, /*!< An update to the Nearest Common Replay Timestamp by the producer.
                               * The timestamp is stored in the \ref ps_rnr_msg.control_data field,
                               * type unsigned long long. [microseconds] */
    //
    //
    RNR_MSG_REPLAY_SYNC_WAIT, /*!< Producer is waiting for other nodes to sync their replay logfile session
                               * to the Nearest Common Replay Timestamp.
                               * The number of node's the producer is waiting on (per host) is stored
                               * in the \ref ps_rnr_msg.control_data field, type unsigned long long. */
    //
    //
    RNR_MSG_SET_FILE_NAME, /*!< Manually set the RnR session file name.
                            * This is usually handled automatically by the Logfile API, but can be set manually.
                            * The file name string is stored in the \ref ps_rnr_msg.control_data field,
                            * type string. */
    //
    //
    RNR_MSG_SET_MODE, /*!< Set producer's logfile mode and session identifier.
                       * The desired mode is indicated by the \ref ps_rnr_msg.mode field.
                       * The desired session identifier is indicated by the \ref ps_rnr_msg.session_id field. */
    //
    //
    RNR_MSG_SET_STATE, /*!< Set producer's logfile state. This is used to pause/resume the logfile's current mode.
                        * If using to start/resume read mode, an optional absolute UTC microsecond start time can be specified using the
                        * \ref ps_rnr_msg.control_data field, type unsigned long long. If value type is \ref PARAMETER_VALUE_UNKNOWN
                        * or value is zero, replay starts immediately.
                        * The desired state is indicated by the \ref ps_rnr_msg.state field. */
    //
    //
    RNR_MSG_SET_REPLAY_POSITION, /*!< Set producer's logfile current replay position timestamp. This is
                                  * used to provide a seek mechanism. The timestamp value is
                                  * between the beggining and end timestamps of the producer's logfile.
                                  * The producer will set its position to the entry who's timestamp
                                  * is nearest the specified value.
                                  * The desired position timestamp is indicated by the \ref ps_rnr_msg.current_timestamp field. */
    //
    //
    RNR_MSG_SET_REPLAY_CLOCK_SCALE, /*!< Set producer's logfile replay clock scale. This value applies a scaling factor the
                                     * replay system clock.
                                     * 1.0 means no effect.
                                     * Less than 1.0 means to slow down.
                                     * Greater than 1.0 means to speed up.
                                     * The desired value is indicated by the \ref ps_rnr_msg.clock_scale field. */
    //
    //
    RNR_MSG_STEP_REPLAY_FORWARD, /*!< Step producer's logfile replay record entry forward.
                                  * If producer is (paused) in mode \ref LOGFILE_MODE_READ, and state \ref LOGFILE_STATE_DISABLED,
                                  * then this will cause the producer to replay the next message in the logfile. */
    //
    //
    RNR_MSG_STEP_REPLAY_BACKWARD, /*!< Step producer's logfile replay record entry backward.
                                   * If producer is (paused) in mode \ref LOGFILE_MODE_READ, and state \ref LOGFILE_STATE_DISABLED,
                                   * then this will cause the producer to replay the previous message in the logfile. */
    //
    //
    RNR_MSG_GET_RNR_SESSIONS, /*!< Get all RnR sessions available on the recievers host.
                               * This is usually handled by the PolySync Manager node, and will be followed with a response \ref ps_rnr_sessions_msg message.
                               * No other fields in \ref ps_rnr_msg are used. */
    //
    //
    RNR_MSG_KIND_COUNT /*!< Number of \ref ps_rnr_msg_kind values. */
};


/**
 * @brief Logfile mode kinds.
 *
 */
enum ps_logfile_mode_kind
{
    //
    //
    LOGFILE_MODE_INVALID, /*!< Invalid logfile mode. */
    //
    //
    LOGFILE_MODE_OFF, /*!< Logfile is not open. */
    //
    //
    LOGFILE_MODE_READ, /*!< Logfile is open for reading. */
    //
    //
    LOGFILE_MODE_WRITE, /*!< Logfile is open for writing. */
    //
    //
    LOGFILE_MODE_KIND_COUNT /*!< Number of \ref ps_logfile_mode_kind values. */
};


/**
 * @brief Logfile state kinds.
 *
 */
enum ps_logfile_state_kind
{
    //
    //
    LOGFILE_STATE_INVALID, /*!< Invalid logfile state. */
    //
    //
    LOGFILE_STATE_DISABLED, /*!< Logfile is disabled (ie paused). */
    //
    //
    LOGFILE_STATE_ENABLED, /*!< Logfile is enabled. */
    //
    //
    LOGFILE_STATE_KIND_COUNT /*!< Number of \ref ps_logfile_state_kind values. */
};


/**
 * @brief Node state kinds used by the PolySync node state machine.
 *
 * Node states are referenced in the PolySync node template, and define all possible states a node may operate in.
 * While conforming to the PolySync node template a user must manually transition a node from one state to another.
 *
 */
enum ps_node_state_kind
{
    //
    //
    NODE_STATE_INVALID, /*!< Invalid node state. */
    //
    //
    NODE_STATE_AUTH, /*!< Node is being authenticated. Node is not a valid domain participant and does not have a GUID. */
    //
    //
    NODE_STATE_INIT, /*!< Node is initializing. Node is a valid domain participant and has a GUID. */
    //
    //
    NODE_STATE_OK, /*!< Node is running. */
    //
    //
    NODE_STATE_WARN, /*!< Fault code is set. May lead to a failure. Fault is not fatal to the operation or the application. Node can continue normal operation and can possibly recover. Node typically can auto-recover without intervention. */
    //
    //
    NODE_STATE_ERROR, /*!< Fault code is set. Failure will occur. Fault is fatal to the operation but NOT the application. Node can NOT continue normal operation. User intervention typically required to recover. */
    //
    //
    NODE_STATE_FATAL, /*!< Fault code is set. Failure will occur. Fault is fatal to the operation AND the application. Node can NOT continue normal operation and may terminate to prevent data loss or further data loss. User intervention typically required to recover. */
    //
    //
    NODE_STATE_KIND_COUNT /*!< Number of \ref ps_node_state_kind values. */
};


/**
 * @brief Node flag kinds for PolySync diagnostic state messages.
 *
 * The node flag kinds are used with @ref ps_diagnostic_state to indicate the operating status or mode.
 *
 */
enum ps_node_flag_kind
{
    //
    //
    NODE_FLAG_VALID, /*!< Node is valid. */
    //
    //
    NODE_FLAG_DEBUG, /*!< Debug enabled. */
    //
    //
    NODE_FLAG_HANDLERS_ENABLED, /*!< Core/user on_data handlers are enabled. */
    //
    //
    NODE_FLAG_RNR_CLOCK_OWNER, /*!< PolySync RnR clock was started, and is owned by this node. */
    //
    //
    NODE_FLAG_PTP_DETECTED, /*!< PTP service detected or in-use. */
    //
    //
    NODE_FLAG_LOGFILE_ENABLED, /*!< Logfile service detected or in-use. */
    //
    //
    NODE_FLAG_MANAGER_DETECTED, /*!< PolySync manager service detected or in-use. */
    //
    //
    NODE_FLAG_KIND_COUNT /*!< Number of \ref ps_node_flag_kind values. */
};


/**
 * @brief Signal kinds.
 *
 */
enum ps_signal_kind
{
    //
    //
    SIGNAL_INVALID, /*!< Invalid signal kind. */
    //
    //
    SIGNAL_UNKNOWN, /*!< Unknown signal kind. */
    //
    //
    SIGNAL_NOT_AVAILABLE, /*!< Signal kind not available. */
    //
    //
    SIGNAL_DIGITAL_INPUT, /*!< Digital input signal. */
    //
    //
    SIGNAL_DIGITAL_OUTPUT, /*!< Digital output signal. */
    //
    //
    SIGNAL_ANALOG_INPUT, /*!< Analog input signal. */
    //
    //
    SIGNAL_ANALOG_OUTPUT, /*!< Analog output signal. */
    //
    //
    SIGNAL_KIND_COUNT /*!< Number of \ref ps_signal_kind values. */
};


/**
 * @brief Reliability QoS kinds.
 *
 */
enum ps_reliability_qos_kind
{
    //
    //
    RELIABILITY_QOS_INVALID, /*!< Invalid reliability QoS kind. */
    //
    //
    RELIABILITY_QOS_UNKNOWN, /*!< Unknown reliability QoS kind. */
    //
    //
    RELIABILITY_QOS_AVAILABLE, /*!< Reliability QoS kind not available. */
    //
    //
    RELIABILITY_QOS_DEFAULT, /*!< Default API provided reliability QoS. */
    //
    //
    RELIABILITY_QOS_BEST_EFFORT, /*!< Best effort reliability QoS. */
    //
    //
    RELIABILITY_QOS_RELIABLE, /*!< Reliable reliability QoS. */
    //
    //
    RELIABILITY_QOS_KIND_COUNT /*!< Number of \ref ps_reliability_qos_kind values. */
};


/**
 * @brief Parameter message kinds.
 *
 */
enum ps_parameter_message_kind
{
    //
    //
    PARAMETER_MESSAGE_INVALID, /*!< Invalid parameter message kind. */
    //
    //
    PARAMETER_MESSAGE_UNKNOWN, /*!< Unknown parameter message kind. */
    //
    //
    PARAMETER_MESSAGE_RESPONSE, /*!< Message is a parameter response. */
    //
    //
    PARAMETER_MESSAGE_GET_VALUE, /*!< Message is a command to get parameter value(s) without descriptions. */
    //
    //
    PARAMETER_MESSAGE_GET_ALL, /*!< Message is a command to get all parameters (both description and value). */
    //
    //
    PARAMETER_MESSAGE_SET_VALUE, /*!< Message is a command to set parameter value(s). Not supported if parameter value is read-only. */
    //
    //
    PARAMETER_MESSAGE_SET_MIN, /*!< Message is a command to set parameter range minimum value(s). Not supported if parameter minimum value is read-only. */
    //
    //
    PARAMETER_MESSAGE_SET_MAX, /*!< Message is a command to set parameter range maximum value(s). Not supported if parameter maximum value is read-only. */
    //
    //
    PARAMETER_MESSAGE_SET_STEP, /*!< Message is a command to set parameter range step value(s). Not supported if parameter step step is read-only. */
    //
    //
    PARAMETER_MESSAGE_SET_VALUE_MIN_MAX, /*!< Message is a command to set parameter range value, minimum, and maximum value(s). Not supported if parameter value/min/max is read-only. */
    //
    //
    PARAMETER_MESSAGE_KIND_COUNT /*!< Number of \ref ps_parameter_message_kind values. */
};


/**
 * @brief Parameter value kinds.
 *
 */
enum ps_parameter_value_kind
{
    //
    //
    PARAMETER_VALUE_UNKNOWN, /*!< Unknown parameter value kind. */
    //
    //
    PARAMETER_VALUE_ULONGLONG, /*!< Parameter value type is unsigned long long. */
    //
    //
    PARAMETER_VALUE_LONGLONG, /*!< Parameter value type is long long. */
    //
    //
    PARAMETER_VALUE_DOUBLE, /*!< Parameter value type is double. */
    //
    //
    PARAMETER_VALUE_STRING, /*!< Parameter value type is char sequence. */
    //
    //
    PARAMETER_VALUE_KIND_COUNT /*!< Number of \ref ps_parameter_value_kind values. */
};


/**
 * @brief Pixel format kinds.
 *
 */
enum ps_pixel_format_kind
{
    //
    //
    PIXEL_FORMAT_INVALID, /*!< Invalid pixel format kind. */
    //
    //
    PIXEL_FORMAT_UNKNOWN, /*!< Unknown pixel format kind. */
    //
    //
    PIXEL_FORMAT_NOT_AVAILABLE, /*!< Pixel format kind not available. */
    //
    //
    PIXEL_FORMAT_MJPEG, /*!< MJPG multiplexed stream, compressed format. */
    //
    //
    PIXEL_FORMAT_MPEG, /*!< MPEG multiplexed stream, compressed format. */
    //
    //
    PIXEL_FORMAT_H264, /*!< H264 video elementary stream with start codes, compressed format. */
    //
    //
    PIXEL_FORMAT_MPEG1, /*!< MPEG1 video elementary stream, compressed format. */
    //
    //
    PIXEL_FORMAT_MPEG2, /*!< MPG2 video elementary stream, compressed format. */
    //
    //
    PIXEL_FORMAT_MPEG4, /*!< MPG4 video elementary stream, compressed format. */
    //
    //
    PIXEL_FORMAT_BGR24, /*!< BGR3, packed RGB format. */
    //
    //
    PIXEL_FORMAT_RGB24, /*!< RGB3, packed RGB format. */
    //
    //
    PIXEL_FORMAT_YUV444, /*!< YUV444, packed YUV format. */
    //
    //
    PIXEL_FORMAT_YUV555, /*!< YUVO, packed YUV format. */
    //
    //
    PIXEL_FORMAT_YUV565, /*!< YUVP, packed YUV format. */
    //
    //
    PIXEL_FORMAT_YUV32, /*!< YUV4, packed YUV format. */
    //
    //
    PIXEL_FORMAT_GREY, /*!< Grey-scale, YUV format. */
    //
    //
    PIXEL_FORMAT_YUYV, /*!< YUYV, packed YUV format with 1/2 horizontal chroma resolution, also known as YUV 4:2:2. */
    //
    //
    PIXEL_FORMAT_Y41P, /*!< Y41P, packed YUV format with 1/4 horizontal chroma resolution, also known as YUV 4:1:1. */
    //
    //
    PIXEL_FORMAT_YUV411P, /*!< 411P, planar YUV format with 1/4 horizontal chroma resolution, also known as YUV 4:1:1. */
    //
    //
    PIXEL_FORMAT_YUV420, /*!< YU12, planar YUV format with 1/2 horizontal and vertical chroma resolution, also known as YUV 4:2:0. */
    //
    //
    PIXEL_FORMAT_YUV422P, /*!< 422P, planar YUV format with 1/2 horizontal chroma resolution, also known as YUV 4:2:2. */
    //
    //
    PIXEL_FORMAT_KIND_COUNT /*!< Number of \ref ps_pixel_format_kind values. */
};


/**
 * @brief File transfer mode kinds.
 *
 */
enum ps_file_transfer_mode_kind
{
    //
    //
    FILE_TRANSFER_MODE_INVALID, /*!< Invalid file transfer mode kind. */
    //
    //
    FILE_TRANSFER_MODE_READ, /*!< File transfer mode read.
                              * Open file for reading. */
    //
    //
    FILE_TRANSFER_MODE_WRITE, /*!< File transfer mode write.
                               * Open file for writing.
                               * If the file already exist, its contents are overwritten. */
    //
    //
    FILE_TRANSFER_MODE_APPEND, /*!< File transfer mode append.
                                * Open file for appending. */
    //
    //
    FILE_TRANSFER_MODE_KIND_COUNT /*!< Number of \ref ps_file_transfer_mode_kind values. */
};




/**
 * @brief Parameter value.
 *
 */
union ps_parameter_value switch( ps_parameter_value_kind )
{
    case PARAMETER_VALUE_UNKNOWN:
    case PARAMETER_VALUE_KIND_COUNT:
    case PARAMETER_VALUE_ULONGLONG:
        unsigned long long      ull_value; /*!< unsigned long long. */
    case PARAMETER_VALUE_LONGLONG:
        long long               ll_value; /*!< long long. */
    case PARAMETER_VALUE_DOUBLE:
        double                  d_value; /*!< double. */
    case PARAMETER_VALUE_STRING:
        sequence<char>          str_value; /*!< string. */
};




// *****************************************************
// PolySync data structures
// *****************************************************


/**
 * @brief PolySync version data.
 *
 */
struct ps_version
{
    //
    //
    octet                       major; /*!< Major version digit. */
    //
    //
    octet                       minor; /*!< Minor version digit. */
    //
    //
    unsigned short              subminor; /*!< Sub-minor digit. */
    //
    //
    unsigned long               build_date; /*!< Build date. [UTC seconds] */
};


/**
 * @brief Native timestamp.
 *
 */
struct ps_native_timestamp
{
    //
    //
    octet                       format; /*!< Timestamp format.
                                         * Value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means invalid. */
    //
    //
    unsigned long long          value; /*!< Timestamp value. */
};


/**
 * @brief Message header.
 *
 */
struct ps_msg_header
{
    //
    //
    ps_msg_type                 type; /*!< Message type identifier. */
    //
    //
    ps_timestamp                timestamp; /*!< Message timestamp. [ microseconds ] */
    //
    //
    ps_guid                     src_guid; /*!< Message producer's GUID. */
};


/**
 * @brief Parameter.
 *
 */
struct ps_parameter
{
    //
    //
    ps_parameter_id             id; /*!< Parameter ID.
                                     * Value \ref PSYNC_PARAM_ID_INVALID means invalid.
                                     * Value \ref PSYNC_PARAM_ID_ALL means apply to all (get/set). */
    //
    //
    ps_timestamp                timestamp; /*!< Measurement timestamp. */
    //
    //
    ps_parameter_value          value; /*!< Paramater value, union of supported types, discriminator is in value type. */
    //
    //
    ps_parameter_value          min; /*!< Paramater minimum value, union of supported types, discriminator is in value type.
                                      * If discriminator is \ref PARAMETER_VALUE_UNKNOWN, then not supported. */
    //
    //
    ps_parameter_value          max; /*!< Paramater maximum value, union of supported types, discriminator is in value type.
                                      * If discriminator is \ref PARAMETER_VALUE_UNKNOWN, then not supported. */
    //
    //
    ps_parameter_value          step; /*!< Paramater step value, union of supported types, discriminator is in value type.
                                       * If discriminator is \ref PARAMETER_VALUE_UNKNOWN, then not supported. */
    //
    //
    octet                       flags; /*!< Flags for the paramenter, ie \ref PSYNC_PARAMETER_FLAG_READONLY set by a response. */
    //
    //
    sequence<char>              description; /*!< String description, not mandated, usually set by a response to \ref PARAMETER_MESSAGE_GET_ALL. */
};


/**
 * @brief Diagnostic state.
 *
 */
struct ps_diagnostic_state
{
    //
    //
    ps_timestamp                timestamp; /*!< State transition timestamp. [ microseconds ] */
    //
    //
    ps_guid                     src_guid; /*!< Source GUID. */
    //
    //
    ps_node_state_kind          node_state; /*!< State of the node with respect to the PolySync state machine. */
    //
    //
    ps_node_flags               node_flags; /*!< Node flags for operating mode and status. */
    //
    //
    ps_dtc                      dtc; /*!< Diagnostic trouble code, if active. */
};


/**
 * @brief A member of a generic parameter group.
 *
 */
struct ps_parameter_group_member
{
    //
    //
    ps_parameter_id parameter_id;
            /*!< Parameter's identifier. */
    //
    //
    ps_parameter_group_member_kind kind;
            /*!< Discriminant of the parameter group member.
             * Interpretation depends on definition of parent group. */
    //
    //
    unsigned long order;
            /*!< Ordering in the parent group.
             * Group members will be returned in ascending order. */
};


/**
 * @brief Generic group of parameters.
 *
 */
struct ps_parameter_group_generic
{
    //
    //
    unsigned long id;
            /*!< Group's identifier. */
    //
    //
    unsigned long parameter_list_id;
            /*!< Identifier of the parameter list under which the group exists. */
    //
    //
    unsigned long parent_id;
            /*!< Identifier of parent group. Zero means group has no parent. */
    //
    //
    sequence<char> name;
            /*!< Optional name. */
    //
    //
    ps_parameter_group_kind kind;
            /*!< Discriminant of the parameter group. */
    //
    //
    sequence<ps_parameter_group_member> members;
            /*!< Sequence of group members. */
};


/**
 * @brief Parameter group list.
 *
 * A collection of logically related parameters.
 *
 */
struct ps_parameter_group_list
{
    //
    //
    unsigned long id;
            /*!< Group's identifier. */
    //
    //
    unsigned long parameter_list_id;
            /*!< Identifier of the parameter list under which the group exists. */
    //
    //
    unsigned long parent_id;
            /*!< Identifier of parent group. Zero means group has no parent. */
    //
    //
    sequence<char> name;
            /*!< Optional name. */
    //
    //
    ps_parameter_id toggle_parameter_id;
            /*!< Identifier of optional toggle parameter.
             * If parameter's value is 0 then the list is collapsed.
             * Else, list is expanded. */
    //
    //
    sequence<ps_parameter_id> item_ids;
            /*!< Identifiers of list items. */
};


/**
 * @brief An item in an option list.
 *
 */
struct ps_parameter_group_option_list_item
{
    //
    //
    ps_parameter_id label_id;
            /*!< Identifier of user facing item text. */
    //
    //
    ps_parameter_id value_id;
            /*!< Identifier of value to be set when item is selected. */
};


/**
 * @brief An option values list.
 *
 */
struct ps_parameter_group_option_list
{
    //
    //
    unsigned long id;
            /*!< Group's identifier. */
    //
    //
    unsigned long parameter_list_id;
            /*!< Identifier of the parameter list under which the group exists. */
    //
    //
    unsigned long parent_id;
            /*!< Identifier of parent group. Zero means group has no parent. */
    //
    //
    sequence<char> name;
            /*!< Optional name. */
    //
    //
    ps_parameter_id value_id;
            /*!< Identifier of value to be set when an option is selected. */
    //
    //
    sequence<ps_parameter_group_option_list_item> options;
            /*!< Sequence of available options. */
};


/**
 * @brief A value range input group.
 *
 */
struct ps_parameter_group_value_range
{
    //
    //
    unsigned long id;
            /*!< Group's identifier. */
    //
    //
    unsigned long parameter_list_id;
            /*!< Identifier of the parameter list under which the group exists. */
    //
    //
    unsigned long parent_id;
            /*!< Identifier of parent group. Zero means group has no parent. */
    //
    //
    sequence<char> name;
            /*!< Optional name. */
    //
    //
    ps_parameter_id min_id;
            /*!< Identifier of the input minimum of the range value. */
    //
    //
    ps_parameter_id max_id;
            /*!< Identifier of the input maximum of the range value. */
};


/**
 * @brief SDF parameter value data.
 *
 * Represents a container for SDF parameter value data.
 *
 */
struct ps_sdf_parameter_value
{
    //
    //
    unsigned long               id; /*!< SDF Primary Key.
                                          * Value \ref PSYNC_SDF_ID_INVALID means invalid. */
    //
    //
    unsigned long               parameter_list_id; /*!< Foreign key pointing to the parent parameter list */
    //
    //
    unsigned long               parameter_description_id; /*!< Foreign key pointing to the associated parameter description */
    //
    //
    ps_parameter                parameter; /*!< Parameter associated with key in SDF. */
};


/**
 * @brief SDF IO configuration data.
 *
 * Represents a container for SDF IO configuration data.
 *
 */
struct ps_sdf_io_configuration
{
    //
    //
    unsigned long id; /*!< SDF Primary Key.
                       * Value \ref PSYNC_SDF_ID_INVALID means invalid. */
    //
    //
    unsigned long sensor_configuration_id;
            /*!< Foreign key pointing to associated sensor. */
    //
    //
    unsigned long parameter_list_id;
            /*!< Foreign key pointing to the associated parameter list. */
    //
    //
    sequence<char> name; /*!< Name of the IO configuration. */
    //
    //
    sequence<ps_sdf_parameter_value> parameter_values; /*!< List of additional SDF parameter values associated with the IO configuration. */
};


/**
 * @brief SDF sensor descriptor data.
 *
 * Represents a container for SDF sensor description data.
 *
 * This data falls outside the typically SDF hierarchy, however it is useful for
 * determining the sensor type identifier value for a given sensor name.
 *
 */
struct ps_sdf_sensor_descriptor
{
    //
    //
    ps_sensor_kind  sensor_type; /*!< Primary key in the SDF. */
    //
    //
    sequence<char>  name; /*!< Name of the sensor, following license model. */
    //
    //
    sequence<char>  description; /*!< Description of the sensor. */
};


/**
 * @brief SDF sensor configuration data.
 *
 * Represents a container for SDF sensor configuration data.
 *
 */
struct ps_sdf_sensor_configuration
{
    //
    //
    unsigned long id; /*!< SDF Primary Key.
                       * Value \ref PSYNC_SDF_ID_INVALID means invalid. */
    //
    //
    unsigned long node_configuration_id;
            /*!< Foreign key pointing to associated node. */
    //
    //
    unsigned long parameter_list_id;
            /*!< Foreign key pointing to the associated parameter list. */
    //
    //
    unsigned long sensor_type_id; /* Links this sensor configuration to a
                                   * unique type published by the device interface. */
    //
    //
    sequence<char> name; /*!< Name of the sensor configuration. */
    //
    //
    sequence<ps_sdf_io_configuration> io_configs; /*!< List of SDF IO configurations. */
    //
    //
    sequence<ps_sdf_parameter_value> parameter_values; /*!< List of additional SDF parameter values associated with the sensor configuration. */
};


/**
 * @brief SDF node configuration data.
 *
 * Represents a container for SDF node configuration data.
 *
 */
struct ps_sdf_node_configuration
{
    //
    //
    unsigned long id; /*!< SDF Primary Key.
                       * Value \ref PSYNC_SDF_ID_INVALID means invalid. */
    //
    //
    unsigned long host_configuration_id;
            /*!< Foreign key pointing to associated runtime. */
    //
    //
    unsigned long parameter_list_id;
            /*!< Foreign key pointing the to associated parameter list. */
    //
    //
    octet enabled; /*!< Enabled flag, zero means not enabled. */
    //
    //
    sequence<char> name; /*!< Name of node. */
    //
    //
    sequence<ps_sdf_sensor_configuration> sensor_configs; /*!< List of SDF sensor configurations. */
    //
    //
    sequence<ps_sdf_parameter_value> parameter_values; /*!< List of additional SDF parameter values associated with the node configuration. */
};


/**
 * @brief SDF host configuration data.
 *
 * Represents a container for SDF host configuration data.
 *
 */
struct ps_sdf_host_configuration
{
    //
    //
    unsigned long id; /*!< SDF Primary Key.
                       * Value \ref PSYNC_SDF_ID_INVALID means invalid. */
    //
    //
    unsigned long runtime_configuration_id;
            /*!< Foreign key pointing to associated runtime. */
    //
    //
    unsigned long parameter_list_id;
            /*!< Foreign key pointing to the associated parameter list. */
    //
    //
    octet enabled; /*!< Enabled flag, zero means not enabled. */
    //
    //
    sequence<char> name; /*!< Name of host. */
    //
    //
    sequence<char> interface_address; /*!< PolySync interface address, format "X.X.X.X" or "AUTO". */
    //
    //
    sequence<char> license_file; /*!< Absolute path to license file. [optional] */
    //
    //
    sequence<char> rnr_base_dir; /*!< Absolute path to RnR base directory. */
    //
    //
    sequence<ps_sdf_node_configuration> node_configs; /*!< List of SDF node configurations. */
    //
    //
    sequence<ps_sdf_parameter_value> parameter_values; /*!< List of additional SDF parameter values associated with the host configuration. */
};


/**
 * @brief SDF runtime configuration data.
 *
 */
struct ps_sdf_runtime_configuration
{
    //
    //
    unsigned long id; /*!< SDF Primary Key.
                       * Value \ref PSYNC_SDF_ID_INVALID means invalid. */
    //
    //
    unsigned long parameter_list_id; /*!< Foreign key pointing to the associated parameter list. */
    //
    //
    sequence<char> name; /*!< Name of the runtime configuration. */
    //
    //
    unsigned long domain_id; /*!< Domain ID this runtime operates under. */
    //
    //
    sequence<char> api_version; /*!< PolySync API version. */
    //
    //
    sequence<ps_sdf_host_configuration> host_configs; /*!< List of SDF host configurations. */
    //
    //
    sequence<ps_sdf_parameter_value> parameter_values; /*!< List of additional SDF parameter values associated with the runtime configuration. */
};


/**
 * @brief Transform descriptor.
 *
 * Describes a PolySync transformation.
 * See \ref polysync_transform.h for more information.
 *
 */
struct ps_transform_descriptor
{
    //
    //
    ps_identifier               id; /*!< Coordinate frame identifier.
                                     * Value \ref PSYNC_COORDINATE_FRAME_INVALID means invalid. */
    //
    //
    ps_timestamp                timestamp; /*!< Last update timestamp. */
    //
    //
    double                      origin[3]; /*!< Origin position. [xyz meters] */
    //
    //
    double                      orientation[4]; /*!< Orientation quaternion. [xyzw quaternion] */
};


/**
 * @brief Transform stack.
 *
 * Contains a PolySync transformation stack.
 * See \ref polysync_transform.h for more information.
 *
 */
struct ps_transform_stack
{
    //
    //
    ps_identifier               parent_id; /*!< Parent coordinate frame identifier.
                                            * Value \ref PSYNC_COORDINATE_FRAME_INVALID means invalid. */
    //
    //
    ps_timestamp                timestamp; /*!< Last update timestamp of the parent and/or any of its children transformations. */
    //
    //
    sequence<ps_transform_descriptor> stack; /*!< Transformation stack. */
};


/**
 * @brief PolySync logfile (.plog) attributes.
 *
 * Describes a PolySync logfile.
 *
 */
struct ps_rnr_logfile_attributes
{
    //
    //
    sequence<char> filename; /*!< File name. */
    //
    //
    sequence<char> absolute_path; /*!< Absolute path to the file, including the file name. */
    //
    //
    sequence<char> node_name; /*!< Name of the node who created the file. */
    //
    //
    ps_guid node_guid; /*!< GUID of the node who created the file. */
    //
    //
    ps_timestamp start_time; /*!< First timestamp in the file. [UTC microseconds] */
    //
    //
    ps_timestamp end_time; /*!< Last timestamp in the file. [UTC microseconds] */
    //
    //
    ps_timestamp duration; /*!< File duration. [microseconds] */
    //
    //
    unsigned long file_size; /*!< File size. [bytes] */
    //
    //
    unsigned long record_offset; /*!< Offset of the first record in the file. [bytes] */
    //
    //
    unsigned long record_count; /*!< Number of record entries in the file. */
};


/**
 * @brief PolySync Record and Replay session.
 *
 * Describes a PolySync RnR session.
 *
 */
struct ps_rnr_session
{
    //
    //
    ps_rnr_session_id id; /*!< Session identifier.
                           * Value \ref PSYNC_RNR_SESSION_ID_INVALID means invalid.
                           * This usually represents the UTC timestamp when the session
                           * was created, however arbritrary values are allowed. */
    //
    //
    sequence<ps_rnr_logfile_attributes> logfile_attributes; /*!< Logfile attributes associated with the RnR session. */
};


/**
 * @brief PolySync Manager runtime node status.
 *
 * Describes a PolySync runtime node as seen by the Manager node.
 *
 */
struct ps_runtime_node_status
{
    //
    //
    ps_identifier process_id; /*!< The node's process identifier.
                               * Value \ref PSYNC_IDENTIFIER_INVALID means the node is not current running. */
    //
    //
    ps_dtc dtc; /*!< Diagnostic trouble code associated with the process status. */
    //
    //
    unsigned long sdf_node_id; /*!< SDF node configuration primary key.
                                * Value \ref PSYNC_SDF_ID_INVALID means invalid. */
    //
    //
    sequence<char> name; /*!< Name of the node as defined in the SDF node configuration. */
    //
    //
    octet replay_mode; /*!< Flag indicating the node is in replay mode.
                        * Value zero means not in replay mode.
                        * Value one means the node is running in replay mode. */
};


/**
 * @brief File synchronization options.
 *
 */
struct ps_file_sync_options
{
    //
    //
    ps_guid source_guid; /*!< GUID of the file's source node. */
    //
    //
    ps_guid destination_guid; /*!< GUID of the file's destination node. */
    //
    //
    char source_path[ PSYNC_FILE_SYNC_PATH_LENGTH ]; /*!< Path to source file. */
    //
    //
    char destination_path[ PSYNC_FILE_SYNC_PATH_LENGTH ]; /*!< Path to destination file. */
};
///@cond INTERNAL
#pragma cats ps_file_sync_options source_path destination_path
///@endcond




// *****************************************************
// PolySync message types
// *****************************************************


/**
 * @brief Diagnostic trace message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_diagnostic_trace_msg
{
    //
    //
    ps_msg_header                   header; /*!< Message header. */
    //
    //
    ps_interface_address            host_address; /*!< Producer's host interface address value.
                                                   * Value \ref PSYNC_INTERFACE_ADDRESS_INVALID means invalid.
                                                   * Value \ref PSYNC_INTERFACE_ADDRESS_AUTO means address is set to 'AUTO'. */
    //
    //
    ps_version                      api_version; /*!< PolySync API version used by the producer. */
    //
    //
    ps_version                      core_version; /*!< PolySync data model 'core' module version used by the producer. */
    //
    //
    sequence<ps_diagnostic_state>   trace; /*!< Trace buffer. */
};
///@cond INTERNAL
#pragma keylist ps_diagnostic_trace_msg          header.src_guid
#pragma expose  ps_diagnostic_trace_msg
///@endcond


/**
 * @brief Byte array message.
 *
 * Arbitration key member(s): header.src_guid, dest_guid
 *
 */
struct ps_byte_array_msg
{
    //
    //
    ps_msg_header                   header; /*!< Message header. */
    //
    //
    ps_guid                         dest_guid; /*!< Destination GUID. */
    //
    //
    unsigned long                   data_type; /*!< User-defined data type. */
    //
    //
    sequence<octet>                 bytes; /*!< Data buffer. */
};
///@cond INTERNAL
#pragma keylist ps_byte_array_msg  header.src_guid, dest_guid
#pragma expose  ps_byte_array_msg
///@endcond


/**
 * @brief CAN frame message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_can_frame_msg
{
    //
    //
    ps_msg_header                   header; /*!< Message header. */
    //
    //
    ps_timestamp                    timestamp; /*!< Receive timestamp. [microseconds] */
    //
    //
    ps_native_timestamp             native_timestamp; /*!< Native receive timestamp, not enforced. */
    //
    //
    ps_identifier                   hardware_id; /*!< Hardware identifier.
                                                  * This is usually the serial number of the adapter hardware, not the channels.
                                                  * (ie. For a 2 channel PCI adapter,
                                                  * it would provide channel ID's 0 and 1, both with the same hardware ID.) */
    //
    //
    unsigned short                  circuit_id; /*!< Circuit identifier.
                                                 * This is usually the index of the channel/circuit on a given piece of hardware.
                                                 * (ie. For a 2 channel PCI adapter, it would provide circuit ID's 0 and 1.) */
    //
    //
    ps_identifier                   system_id; /*!< System identifier.
                                                * This is usually the system index of the channel as seen by the host driver,
                                                * or software stack. The system ID is not typically a reliable way of persisting
                                                * channel configurations accross reboots. Instead, it is recommended to use the
                                                * hardware ID and circuit ID to determine the system ID before use. */
    //
    //
    ps_identifier                   id; /*!< CAN frame identifier. */
    //
    //
    unsigned short                  flags; /*!< CAN frame flags. */
    //
    //
    sequence<octet>                 data_buffer; /*!< CAN frame data buffer. */
};
///@cond INTERNAL
#pragma keylist ps_can_frame_msg     header.src_guid
#pragma expose  ps_can_frame_msg
///@endcond


/**
 * @brief Event message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_event_msg
{
    //
    //
    ps_msg_header                   header; /*!< Message header. */
    //
    //
    ps_guid                         dest_guid; /*!< Destination GUID. */
    //
    //
    ps_event_id                     id; /*!< Event ID. */
    //
    //
    ps_parameter_value              data; /*!< Generic paramater value associated with the event, union of supported types, discriminator is in value type. */
};
///@cond INTERNAL
#pragma keylist ps_event_msg        header.src_guid
#pragma expose  ps_event_msg
///@endcond


/**
 * @brief Parameters message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_parameters_msg
{
    //
    //
    ps_msg_header                   header; /*!< Message header. */
    //
    //
    ps_guid                         dest_guid; /*!< Destination GUID. */
    //
    //
    ps_parameter_message_kind       type; /*!< Parameter message type. */
    //
    //
    sequence<ps_parameter>          parameters; /*!< Parameter buffer.
                                                 * To request all parameters,
                                                 * set element zero parameter ID to \ref PSYNC_PARAM_ID_ALL. */
};
///@cond INTERNAL
#pragma keylist ps_parameters_msg         header.src_guid
#pragma expose  ps_parameters_msg
///@endcond


/**
 * @brief Record and Replay message.
 *
 * Provides status and control of PolySync Nodes using the Logfile
 * and RnR API utilities.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_rnr_msg
{
    //
    //
    ps_msg_header                   header; /*!< Message header. */
    //
    //
    ps_rnr_session_id               session_id; /*!< Session identifier. */
    //
    //
    ps_interface_address            host_address; /*!< Producer's host interface address value.
                                                   * Value \ref PSYNC_INTERFACE_ADDRESS_INVALID means invalid.
                                                   * Value \ref PSYNC_INTERFACE_ADDRESS_AUTO means address is set to 'AUTO'. */
    //
    //
    ps_guid                         dest_guid; /*!< Optional destination node GUID. Used to target a specific destination node by GUID.
                                                * Value \ref PSYNC_GUID_INVALID means all nodes should handle the message. */
    //
    //
    ps_rnr_msg_kind                 type; /*!< RnR message type. Provides details on interpretting the message fields. */
    //
    //
    ps_logfile_mode_kind            mode; /*!< Logfile mode. */
    //
    //
    ps_logfile_state_kind           state; /*!< Logfile state. */
    //
    //
    ps_timestamp                    current_timestamp; /*!< Current logfile timestamp. [microseconds] */
    //
    //
    ps_timestamp                    begin_timestamp; /*!< Beginning logfile entry's timestamp.
                                                      * When in \ref LOGFILE_MODE_READ, this represents the
                                                      * Nearest Common Replay Timestamp.
                                                      * When in \ref LOGFILE_MODE_WRITE, this represents the
                                                      * first entry's timestamp. [microseconds] */
    //
    //
    ps_timestamp                    end_timestamp; /*!< Ending logfile entry's timestamp. [microseconds] */
    //
    //
    double                          clock_scale; /*!< Replay clock tick scale.
                                                  * Value \ref PSYNC_CLOCK_SCALE_INVALID means not available. */
    //
    //
    sequence<char>                  file_path; /*!< Logfile's binary file path. */
    //
    //
    ps_parameter_value              control_data; /*!< Control data used by certain \ref ps_rnr_message_kind values. */
};
///@cond INTERNAL
#pragma keylist ps_rnr_msg          header.src_guid
#pragma expose  ps_rnr_msg
///@endcond


/**
 * @brief SDF state message.
 *
 * Provides the state of the SDF configuration as seen by the publisher.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_sdf_state_msg
{
    //
    //
    ps_msg_header                   header; /*!< Message header. */
    //
    //
    ps_sdf_runtime_configuration    runtime_configuration; /*!< SDF runtime configuration used by the publisher. */
};
///@cond INTERNAL
#pragma keylist ps_sdf_state_msg    header.src_guid
#pragma expose  ps_sdf_state_msg
///@endcond


/**
 * @brief Record and Replay sessions message.
 *
 * Provides the currently available RnR sessions as seen by the publisher.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_rnr_sessions_msg
{
    //
    //
    ps_msg_header header; /*!< Message header. */
    //
    //
    ps_interface_address host_address; /*!< Producer's host interface address value.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_INVALID means invalid.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_AUTO means address is set to 'AUTO'. */
    //
    //
    sequence<ps_rnr_session> sessions; /*!< RnR sessions. */
};
///@cond INTERNAL
#pragma keylist ps_rnr_sessions_msg header.src_guid
#pragma expose  ps_rnr_sessions_msg
///@endcond


/**
 * @brief File transfer message.
 *
 * Used to initialize a file transfer between publisher and subscriber.
 *
 * Arbitration key member(s): header.src_guid, dest_guid
 *
 */
struct ps_file_transfer_msg
{
    //
    //
    ps_msg_header header; /*!< Message header. */
    //
    //
    ps_interface_address host_address; /*!< Producer's host interface address value.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_INVALID means invalid.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_AUTO means address is set to 'AUTO'. */
    //
    //
    ps_guid dest_guid; /*!< Destination node GUID.
                        * Used to target a specific destination node by GUID.
                        * Value \ref PSYNC_GUID_INVALID means all nodes should handle the message. */
    //
    //
    ps_file_transfer_mode_kind mode; /*!< File transfer mode.
                                      * Determines whether this is a read/write/append operation.
                                      * Value \ref FILE_TRANSFER_MODE_INVALID means invalid. */
    //
    //
    sequence<char> absolute_path; /*!< Absolute path to the file, including the file name. */
    //
    //
    unsigned long chunk_size; /*!< File fragmentation chunk size.
                               * Files will be fragmented in to chunks of this size when published in \ref ps_file_msg.
                               * Value zero means use the receivers default value. [bytes] */
    //
    //
    ps_timestamp inter_chunk_delay; /*!< Amount of time between file data chunks, see \ref ps_msg_msg.
                                     * Value zero means use the receivers default value. [microseconds] */
    //
    //
    octet require_hash; /*!< File hash required flag.
                         * Value zero menas not required.
                         * Value one means required. */
};
///@cond INTERNAL
#pragma keylist ps_file_transfer_msg header.src_guid, dest_guid
#pragma expose ps_file_transfer_msg
///@endcond


/**
 * @brief Extended file transfer message.
 *
 * Used to initialize a file transfer between publisher and subscriber.
 *
 * Arbitration key member(s): header.src_guid, destination_guid, mode, destination_path
 *
 */
struct ps_file_transfer_ext_msg
{
    //
    //
    ps_msg_header header; /*!< Message header. */
    //
    //
    ps_interface_address host_address; /*!< Producer's host interface address value.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_INVALID means invalid.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_AUTO means address is set to 'AUTO'. */
    //
    //
    ps_guid destination_guid; /*!< Destination node GUID.
                               * Used to target a specific destination node by GUID.
                               * Value \ref PSYNC_GUID_INVALID means all nodes should handle the message. */
    //
    //
    ps_file_transfer_mode_kind mode; /*!< File transfer mode.
                                      * Determines whether this is a read/write/append operation.
                                      * Value \ref FILE_TRANSFER_MODE_INVALID means invalid. */
    //
    //
    char source_path[ PSYNC_FILE_TRANSFER_PATH_LENGTH ]; /*!< Absolute path to the source file, including the file name. */
    //
    //
    char destination_path[ PSYNC_FILE_TRANSFER_PATH_LENGTH ]; /*!< Absolute path to the destination file, including the file name. */
    //
    //
    unsigned long chunk_size; /*!< File fragmentation chunk size.
                               * Files will be fragmented in to chunks of this size when published in \ref ps_file_msg.
                               * Value zero means use the receivers default value. [bytes] */
    //
    //
    ps_timestamp inter_chunk_delay; /*!< Amount of time between file data chunks, see \ref ps_msg_msg.
                                     * Value zero means use the receivers default value. [microseconds] */
    //
    //
    octet require_hash; /*!< File hash required flag.
                         * Value zero menas not required.
                         * Value one means required. */
};
///@cond INTERNAL
#pragma cats ps_file_transfer_ext_msg destination_path
#pragma keylist ps_file_transfer_ext_msg header.src_guid, destination_guid, mode, destination_path
#pragma expose ps_file_transfer_ext_msg
///@endcond


/**
 * @brief File data message.
 *
/**
 * @brief File data message.
 *
 * Used to transfer file data between publisher and subscriber.
 *
 * Files are typically fragmented using the chunk size.
 * The chunk identifier and chunk offset allows the subscriber
 * to reconstruct the data fragments.
 *
 * @note The field ps_file_msg.chunk_id starts at value one.
 *
 * Arbitration key member(s): header.src_guid, dest_guid, chunk_id
 *
 */
struct ps_file_msg
{
    //
    //
    ps_msg_header header; /*!< Message header. */
    //
    //
    ps_interface_address host_address; /*!< Producer's host interface address value.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_INVALID means invalid.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_AUTO means address is set to 'AUTO'. */
    //
    //
    ps_guid dest_guid; /*!< Destination node GUID.
                        * Used to target a specific destination node by GUID.
                        * Value \ref PSYNC_GUID_INVALID means all nodes should handle the message. */
    //
    //
    sequence<char> absolute_path; /*!< Absolute path to the file, including the file name. */
    //
    //
    unsigned long file_size; /*!< File size. [bytes] */
    //
    //
    octet file_hash[PSYNC_MODULE_VERIFY_HASH_LEN]; /*!< File hash.
                                                    * Typically the MD5 hash of the file, see \ref psync_get_file_hash. */
    //
    //
    unsigned long chunk_id; /*!< Current data chunk identifier.
                             * Value zero means invalid.
                             * The first chunk will have the value one. */
    //
    //
    unsigned long chunk_offset; /*!< Offset of this data chunk in the file.
                                 * The first chunk will have an offset value of zero. [bytes] */
    //
    //
    unsigned long total_chunks; /*!< Total number of chunks used to fragment the file data. */
    //
    //
    ps_dtc dtc; /*!< Diagnostic trouble code associated with the last update to the file transfer operation. */
    //
    //
    sequence<octet> bytes; /*!< Data bytes associated with the chunk. */
};
///@cond INTERNAL
#pragma keylist ps_file_msg header.src_guid, dest_guid, chunk_id
#pragma expose ps_file_msg
///@endcond


/**
 * @brief Extended file data message.
 *
 * Used to transfer file data between publisher and subscriber.
 *
 * Files are typically fragmented using the chunk size.
 * The chunk identifier and chunk offset allows the subscriber
 * to reconstruct the data fragments.
 *
 * @note The field ps_file_ext_msg.chunk_id starts at value one.
 * @note Differs from ps_file_msg due to larger file_size and chunk_offset fields.
 *
 * Arbitration key member(s): header.src_guid, destination_guid, chunk_id, destination_path
 *
 */
struct ps_file_ext_msg
{
    //
    //
    ps_msg_header header; /*!< Message header. */
    //
    //
    ps_interface_address host_address; /*!< Producer's host interface address value.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_INVALID means invalid.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_AUTO means address is set to 'AUTO'. */
    //
    //
    ps_guid destination_guid; /*!< Destination node GUID.
                               * Used to target a specific destination node by GUID.
                               * Value \ref PSYNC_GUID_INVALID means all nodes should handle the message. */
    //
    //
    char source_path[ PSYNC_FILE_TRANSFER_PATH_LENGTH ]; /*!< Absolute path to the source file, including the file name. */
    //
    //
    char destination_path[ PSYNC_FILE_TRANSFER_PATH_LENGTH ]; /*!< Absolute path to the destination file, including the file name. */
    //
    //
    unsigned long long file_size; /*!< File size. [bytes] */
    //
    //
    octet file_hash[PSYNC_MODULE_VERIFY_HASH_LEN]; /*!< File hash.
                                                    * Typically the MD5 hash of the file, see \ref psync_get_file_hash. */
    //
    //
    unsigned long chunk_id; /*!< Current data chunk identifier.
                             * Value zero means invalid.
                             * The first chunk will have the value one. */
    //
    //
    unsigned long long chunk_offset; /*!< Offset of this data chunk in the file.
                                      * The first chunk will have an offset value of zero. [bytes] */
    //
    //
    unsigned long total_chunks; /*!< Total number of chunks used to fragment the file data. */
    //
    //
    ps_dtc dtc; /*!< Diagnostic trouble code associated with the last update to the file transfer operation. */
    //
    //
    sequence<octet> bytes; /*!< Data bytes associated with the chunk. */
};
///@cond INTERNAL
#pragma cats ps_file_ext_msg destination_path
#pragma keylist ps_file_ext_msg header.src_guid, destination_guid, chunk_id, destination_path
#pragma expose ps_file_ext_msg
///@endcond


/**
 * @brief Generic command message.
 *
 * Arbitration key member(s): header.src_guid, dest_guid, id
 *
 */
struct ps_command_msg
{
    //
    //
    ps_msg_header header; /*!< Message header. */
    //
    //
    ps_guid dest_guid; /*!< Destination GUID. */
    //
    //
    ps_command_id id; /*!< Command identifier.
                       * Value \ref PSYNC_COMMAND_ID_INVALID means invalid. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the command. [microseconds] */
    //
    //
    sequence<ps_parameter_value> data; /*!< Command data buffer.
                                        * Not used by all commands. */
};
///@cond INTERNAL
#pragma keylist ps_command_msg header.src_guid, dest_guid, id
#pragma expose ps_command_msg
///@endcond


/**
 * @brief Generic response message.
 *
 * Arbitration key member(s): header.src_guid, dest_guid, id
 *
 */
struct ps_response_msg
{
    //
    //
    ps_msg_header header; /*!< Message header. */
    //
    //
    ps_guid dest_guid; /*!< Destination GUID. */
    //
    //
    ps_command_id id; /*!< Command identifier this is responding to.
                       * Value \ref PSYNC_COMMAND_ID_INVALID means invalid. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the response. [microseconds] */
    //
    //
    ps_dtc dtc; /*!< Diagnostic trouble code associated with the command this is responding to. */
    //
    //
    sequence<ps_parameter_value> data; /*!< Response data buffer.
                                        * Not used by all commands/responses. */
};
///@cond INTERNAL
#pragma keylist ps_response_msg header.src_guid, dest_guid, id
#pragma expose ps_response_msg
///@endcond


/**
 * @brief Manager node status message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_manager_status_msg
{
    //
    //
    ps_msg_header header; /*!< Message header. */
    //
    //
    ps_interface_address host_address; /*!< Producer's host interface address value.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_INVALID means invalid.
                                        * Value \ref PSYNC_INTERFACE_ADDRESS_AUTO means address is set to 'AUTO'. */
    //
    //
    unsigned long sdf_runtime_id; /*!< SDF runtime configuration primary key.
                                   * Value \ref PSYNC_SDF_ID_INVALID means invalid. */
    //
    //
    sequence<ps_runtime_node_status> runtime_nodes; /*!< Runtime nodes.
                                                     * Contains the status of each runtime node bing
                                                     * managed by the Manager node. */
};
///@cond INTERNAL
#pragma keylist ps_manager_status_msg header.src_guid
#pragma expose ps_manager_status_msg
///@endcond


struct ps_file_sync_msg
{
    //
    //
    ps_msg_header header; /*!< Message header. */
    //
    //
    ps_file_sync_operation_kind operation; /*!< File synchronization operation/mode. */
    //
    //
    ps_dtc dtc; /*!< Diagnostic trouble code associated with the file sync session. */
    //
    //
    ps_file_sync_options options; /*!< Source and destination node GUIDs and file paths. */
    //
    //
    ps_interface_address source_address; /*!< Interface address used by file's source node. */
    //
    //
    ps_interface_address destination_address; /*!< Interface address used by file's destination node. */
    //
    //
    unsigned short destination_port; /*!< Socket port used by destination node for the file synchronization. */
    //
    //
    unsigned long long file_size; /*!< Size of the file to be synchronized [bytes]. */
};
///@cond INTERNAL
#pragma keylist ps_file_sync_msg operation options.source_guid options.destination_guid options.source_path options.destination_path
#pragma expose ps_file_sync_msg
///@endcond


struct ps_file_sync_status_msg
{
    //
    //
    ps_msg_header header; /*!< Message header. */
    //
    //
    ps_dtc dtc; /*!< Diagnostic trouble code associated with the file sync session. */
    //
    //
    ps_file_sync_options options; /*!< Source and destination node GUIDs and file paths. */
    //
    //
    ps_interface_address source_address; /*!< Interface address used by file's source node. */
    //
    //
    ps_interface_address destination_address; /*!< Interface address used by file's destination node. */
    //
    //
    unsigned long long file_size; /*!< Size of the file to be synchronized [bytes]. */
    //
    //
    unsigned long long bytes_synced; /*!< Number of bytes in the file that have been synchronized [bytes]. */
};
///@cond INTERNAL
#pragma keylist ps_file_sync_status_msg bytes_synced options.source_guid options.destination_guid options.source_path options.destination_path
#pragma expose ps_file_sync_status_msg
///@endcond
/**
 * @file dtc.idl
 * @brief PolySync Data Model Diagnostic Trouble Code Module.
 *
 * Contains specific diagnostic trouble codes.
 * See \ref core.idl for the generic DTC's.
 *
 */




/**
 * @brief DTC module major version. [uint8_t]
 *
 * Indicates a major release version.
 *
 */
const octet DTC_MODULE_VERSION_MAJOR = 2;


/**
 * @brief DTC module minor version. [uint8_t]
 *
 * Indicates a minor release version.
 * Increased each time the syntax of the module
 * is changed (ie new or removed messages, new or removed message fields, changed number of bits, etc).
 *
 */
const octet DTC_MODULE_VERSION_MINOR = 0;


/**
 * @brief DTC module sub-minor version. [uint16_t]
 *
 * Indicates a sub-minor release version.
 * Increased each time the semantics of the
 * data model are modified (ie interpretation of field values or similar).
 *
 */
const unsigned short DTC_MODULE_VERSION_SUBMINOR = 1;




/**
 * @brief Data model shared library file missing error.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_NOPDM = 52;


/**
 * @brief Failed to create PolySync Logfile/RnR wall clock.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_LOGFILE_REPLAY_CLOCK = 53;


/**
 * @brief Logfile contains no message data.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_LOGFILE_EMPTY = 800;


/**
 * @brief Specified replay session identifier does not exist on the host.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_INVALID_REPLAY_SESSION = 801;


/**
 * @brief Process is not responding.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_PROCESS_NOT_RESPONSIVE = 900;


/**
 * @brief PolySync Manager daemon is not responding.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_MANAGER_NOT_RESPONSIVE = 901;


/**
 * @brief PolySync PTP service is not responding.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_PTP_NOT_RESPONSIVE = 902;


/**
 * @brief Command is not available or not supported.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_COMMAND_NOT_AVAILABLE = 1000;


/**
 * @brief Command is missing required data elements.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_COMMAND_NO_DATA = 1001;


/**
 * @brief Command has invalid data elements.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_COMMAND_BAD_DATA = 1002;


/**
 * @brief Request for position index in sequence outside of valid range.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_SEQUENCE_INDEX_OUT_OF_RANGE = 1100;


/**
 * @brief Request for position index in sequence collides with another request.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_SEQUENCE_INDEX_COLLISION = 1101;


/**
 * @brief Value in a container (linked list, hash table, etc) was not found.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_VALUE_NOT_FOUND = 1200;


/**
 * @brief A file transfer request was rejected because it could not be serviced.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_FILE_TRANSFER_REJECTED = 1300;


/**
 * @brief A file transfer reported different file hashes between sender and receiver.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_FILE_TRANSFER_HASH_MISMATCH = 1301;


/**
 * @brief Failed to create message queue.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_MESSAGE_QUEUE = 117;


/**
 * @brief Failed to create shared memory queue.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_SHAREDMEM_QUEUE = 118;


/**
 * @brief Failed to create thread.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_THREAD = 119;


/**
 * @brief Failed to PolySync Logfile API reader thread.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_LOGFILE_READER_THREAD = 120;


/**
 * @brief Failed to PolySync Logfile API writer thread.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_LOGFILE_WRITER_THREAD = 121;


/**
 * @brief Failed to PolySync Logfile API chunk loader thread.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_LOGFILE_CHUNK_THREAD = 122;


/**
 * @brief Failed to create message publisher.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_MESSAGE_PUBLISHER = 123;


/**
 * @brief Failed to create message subscriber.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_MESSAGE_SUBSCRIBER = 124;


/**
 * @brief Failed to read data.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_BAD_READ = 125;


/**
 * @brief Failed to write data.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_BAD_WRITE = 126;


/**
 * @brief Failed to locate PolySync CAN support module/library.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_CAN_MODULE = 312;


/**
 * @brief Failed to locate specified CAN channel on the host.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_NO_CAN_CHANNEL = 313;


/**
 * @brief Failed to apply configuration to the CAN channel.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_CAN_CHANNEL_CONFIG = 314;


/**
 * @brief No valid CAN channel data seen.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_NO_CAN_DATA = 315;


/**
 * @brief Failed to locate PolySync Socket support module/library.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_SOCKET_MODULE = 316;


/**
 * @brief Failed to create socket with specified address/port.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_NO_SOCKET = 317;


/**
 * @brief Failed to apply configuration to the socket.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_SOCKET_CONFIG = 318;


/**
 * @brief No valid socket data seen.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_NO_SOCKET_DATA = 319;


/**
 * @brief Failed to locate PolySync Serial support module/library.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_SERIAL_MODULE = 320;


/**
 * @brief Failed to create serial device interface.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_NO_SERIAL = 321;


/**
 * @brief Failed to apply configuration to the serial device interface.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_SERIAL_CONFIG = 322;


/**
 * @brief No valid serial data seen.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_NO_SERIAL_DATA = 323;


/**
 * @brief Failed to locate PolySync Shared Memory support module/library.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_SHAREDMEM_MODULE = 324;


/**
 * @brief Failed to create shared memory interface.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_NO_SHAREDMEM = 325;


/**
 * @brief Failed to apply configuration to the shared memory segment.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_SHAREDMEM_CONFIG = 326;


/**
 * @brief No valid shared memory data seen.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_NO_SHAREDMEM_DATA = 327;


/**
 * @brief Failed to locate PolySync Video support module/library.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_VIDEO_DEVICE_MODULE = 328;


/**
 * @brief Failed to create video device with specified device path.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_NO_VIDEO_DEVICE = 329;


/**
 * @brief Failed to apply configuration to the video device.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_VIDEO_DEVICE_CONFIG = 330;


/**
 * @brief No valid video device data seen.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_NO_VIDEO_DEVICE_DATA = 331;


/**
 * @brief Failed to apply configuration to the video encoder.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_VIDEO_ENCODER_CONFIG = 332;


/**
 * @brief Failed to apply configuration to the video decoder.
 *
 * Reserved diagnostic trouble code.
 *
 */
const ps_dtc DTC_VIDEO_DECODER_CONFIG = 333;
/**
 * @file sensor.idl
 * @brief PolySync Data Model Sensor Module.
 *
 * All timestamps are in the standard UTC microsecond time domain unless
 * otherwise specified.
 *
 */




/**
 * @brief Sensor module major version. [uint8_t]
 *
 * Indicates a major release version.
 *
 */
const octet                 SENSOR_MODULE_VERSION_MAJOR         = 2;


/**
 * @brief Sensor module minor version. [uint8_t]
 *
 * Indicates a minor release version.
 * Increased each time the syntax of the module
 * is changed (ie new or removed messages, new or removed message fields, changed number of bits, etc).
 *
 */
const octet                 SENSOR_MODULE_VERSION_MINOR         = 0;


/**
 * @brief Sensor module sub-minor version. [uint16_t]
 *
 * Indicates a sub-minor release version.
 * Increased each time the semantics of the
 * data model are modified (ie interpretation of field values or similar).
 *
 */
const unsigned short        SENSOR_MODULE_VERSION_SUBMINOR      = 1;




// *****************************************************
// constants
// *****************************************************


/**
 * @brief Invalid \ref ps_sensor_descriptor.id value.
 *
 */
const ps_identifier PSYNC_SENSOR_ID_INVALID = 0;


/**
 * @brief Unknown \ref ps_sensor_descriptor.id value.
 *
 */
const ps_identifier PSYNC_SENSOR_ID_UNKNOWN = 1;


/**
 * @brief \ref ps_sensor_descriptor.id value not available.
 *
 */
const ps_identifier PSYNC_SENSOR_ID_NOT_AVAILABLE = 2;


/**
 * @brief Position component not available value.
 *
 */
const double PSYNC_POSITION_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Angle component not available value.
 *
 */
const double PSYNC_ANGLE_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Position (floating point type) component not available value.
 *
 */
const double PSYNC_FLOAT_POSITION_NOT_AVAILABLE = -999999.0;


/**
 * @brief Size component not available value.
 *
 */
const double PSYNC_SIZE_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Velocity component not available value.
 *
 */
const double PSYNC_VELOCITY_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Acceleration component not available value.
 *
 */
const double PSYNC_ACCELERATION_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Rotation rate component not available value.
 *
 */
const double PSYNC_ROTATION_RATE_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Orientation quaternion component not available value.
 *
 */
const double PSYNC_ORIENTATION_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Heading angle not available value.
 *
 */
const double PSYNC_HEADING_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Latitude not available value.
 *
 */
const double PSYNC_LATITUDE_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Longitude not available value.
 *
 */
const double PSYNC_LONGITUDE_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Altitude not available value.
 *
 */
const double PSYNC_ALTITUDE_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Velocity/alias component not available value.
 *
 */
const double PSYNC_VELOCITY_ALIAS_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Amplitude not available value.
 *
 */
const double PSYNC_AMPLITUDE_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Magnitude not available value.
 *
 */
const double PSYNC_MAGNITUDE_NOT_AVAILABLE = -999999999.0;


/**
 * @brief Radar cross section not available value.
 *
 */
const double PSYNC_RADAR_CROSS_SECTION_NOT_AVAILABLE = -999999999.0;




// *****************************************************
// enumerated types
// *****************************************************


/**
 * @brief Range kinds.
 *
 */
enum ps_range_kind
{
    //
    //
    RANGE_INVALID, /*!< Range information is invalid. */
    //
    //
    RANGE_UNKNOWN, /*!< Range information is unknown. */
    //
    //
    RANGE_NOT_AVAILABLE, /*!< Range information is not available. */
    //
    //
    RANGE_NONE, /*!< Not in-range. */
    //
    //
    RANGE_NEAR, /*!< Near range. */
    //
    //
    RANGE_MEDIUM, /*!< Medium range. */
    //
    //
    RANGE_LONG, /*!< Long range. */
    //
    //
    RANGE_KIND_COUNT /*!< Number of \ref ps_range_kind values. */
};


/**
 * @brief Zone kinds.
 *
 */
enum ps_zone_kind
{
    //
    //
    ZONE_INVALID, /*!< Zone information is invalid. */
    //
    //
    ZONE_UNKNOWN, /*!< Zone information is unknown. */
    //
    //
    ZONE_NOT_AVAILABLE, /*!< Zone information is not available. */
    //
    //
    ZONE_0, /*!< Zero to less than twenty percent of range. */
    //
    //
    ZONE_1, /*!< Twenty to less than fourty percent of range. */
    //
    //
    ZONE_2, /*!< Fourty to less than sixty percent of range. */
    //
    //
    ZONE_3, /*!< Sixty to less than eighty percent of range. */
    //
    //
    ZONE_4, /*!< Eighty to one hundred percent of range. */
    //
    //
    ZONE_KIND_COUNT /*!< Number of \ref ps_zone_kind values. */
};


/**
 * @brief Quality kinds.
 *
 */
enum ps_quality_kind
{
    //
    //
    QUALITY_INVALID, /*!< Quality information is invalid. */
    //
    //
    QUALITY_UNKNOWN, /*!< Quality information is unknown. */
    //
    //
    QUALITY_NOT_AVAILABLE, /*!< Quality information is not available. */
    //
    //
    QUALITY_0, /*!< Quality zero, lowest quality. */
    //
    //
    QUALITY_1, /*!< Quality one. */
    //
    //
    QUALITY_2, /*!< Quality two. */
    //
    //
    QUALITY_3, /*!< Quality three. */
    //
    //
    QUALITY_4, /*!< Quality four. */
    //
    //
    QUALITY_5, /*!< Quality five. */
    //
    //
    QUALITY_6, /*!< Quality six. */
    //
    //
    QUALITY_7, /*!< Quality seven. */
    //
    //
    QUALITY_8, /*!< Quality eight. */
    //
    //
    QUALITY_9, /*!< Quality nine, highest quality. */
    //
    //
    QUALITY_KIND_COUNT /*!< Number of \ref ps_quality_kind values. */
};


/**
 * @brief Track status kinds.
 *
 */
enum ps_track_status_kind
{
    //
    //
    TRACK_STATUS_INVALID, /*!< Track status information is invalid. */
    //
    //
    TRACK_STATUS_UNKNOWN, /*!< Track status information is unknown. */
    //
    //
    TRACK_STATUS_NOT_AVAILABLE, /*!< Status information on the track is not available. */
    //
    //
    TRACK_STATUS_NO_TRACK, /*!< Track is not valid and should not be considered usable. */
    //
    //
    TRACK_STATUS_RAW_TARGET, /*!< Track is a raw target measurement and is not tracked. */
    //
    //
    TRACK_STATUS_ACTIVE, /*!< Track is active/valid. */
    //
    //
    TRACK_STATUS_CIPV, /*!< Track is flagged as the closest in path vehicle. */
    //
    //
    TRACK_STATUS_NEW,  /*!< Track is new to the tracker, ie the start of a track. */
    //
    //
    TRACK_STATUS_NEW_UPDATED, /*!< Track is new and was updated. */
    //
    //
    TRACK_STATUS_UPDATED, /*!< Track was updated. */
    //
    //
    TRACK_STATUS_COASTED, /*!< Track was coasted. */
    //
    //
    TRACK_STATUS_MERGED, /*!< Track was merged. */
    //
    //
    TRACK_STATUS_INVALID_COASTED, /*!< Track is invalid and was coasted. */
    //
    //
    TRACK_STATUS_NEW_COASTED, /*!< Track is new and was coasted. */
    //
    //
    TRACK_STATUS_KIND_COUNT /*!< Number of \ref ps_track_status_kind values. */
};


/**
 * @brief Object classification kinds.
 *
 */
enum ps_object_classification_kind
{
    //
    //
    OBJECT_CLASSIFICATION_INVALID, /*!< Object classification information is invalid. */
    //
    //
    OBJECT_CLASSIFICATION_UNKNOWN, /*!< Object classification information is unknown. */
    //
    //
    OBJECT_CLASSIFICATION_NOT_AVAILABLE, /*!< Classification information on the object is not available. */
    //
    //
    OBJECT_CLASSIFICATION_UNCLASSIFIED, /*!< Object is unclassified but seen. */
    //
    //
    OBJECT_CLASSIFICATION_UNDECIDED_SMALL, /*!< Object is classified as unknown small. */
    //
    //
    OBJECT_CLASSIFICATION_UNDECIDED_BIG, /*!< Object is classified as unknown big. */
    //
    //
    OBJECT_CLASSIFICATION_BARRIER, /*!< Object is classified as a barrier. */
    //
    //
    OBJECT_CLASSIFICATION_PEDESTRIAN, /*!< Object is classified as a pedestrian. */
    //
    //
    OBJECT_CLASSIFICATION_BIKE, /*!< Object is classified as a bike. */
    //
    //
    OBJECT_CLASSIFICATION_CAR, /*!< Object is classified as a car. */
    //
    //
    OBJECT_CLASSIFICATION_TRUCK, /*!< Object is classified as a truck. */
    //
    //
    OBJECT_CLASSIFICATION_KIND_COUNT /*!< Number of \ref ps_object_classification_kind values. */
};


/**
 * @brief Lane marker/boundary kinds.
 *
 */
enum ps_lane_marker_kind
{
    //
    //
    LANE_MARKER_INVALID, /*!< Lane marker information is invalid. */
    //
    //
    LANE_MARKER_UNKNOWN, /*!< Lane marker information is unknown. */
    //
    //
    LANE_MARKER_NOT_AVAILABLE, /*!< Lane marker information is not available. */
    //
    //
    LANE_MARKER_NONE, /*!< Lane does not have a marker/boundary line. */
    //
    //
    LANE_MARKER_SOLID, /*!< Solid lane marker. */
    //
    //
    LANE_MARKER_DASHED, /*!< Dashed lane marker. */
    //
    //
    LANE_MARKER_VIRTUAL, /*!< Virtual/implied lane marker. */
    //
    //
    LANE_MARKER_DOTS, /*!< Dotted lane marker. */
    //
    //
    LANE_MARKER_ROAD_EDGE, /*!< Road-edge lane marker. */
    //
    //
    LANE_MARKER_DOUBLE_LINE, /*!< Double-line lane marker. */
    //
    //
    LANE_MARKER_KIND_COUNT /*!< Number of \ref ps_lane_marker_kind values. */
};


/**
 * @brief Lane curve model kinds.
 *
 * See \ref ps_lane_model for example usage documentation.
 *
 */
enum ps_lane_curve_model_kind
{
    //
    //
    LANE_CURVE_MODEL_INVALID, /*!< Lane curve model information is invalid. */
    //
    //
    LANE_CURVE_MODEL_UNKNOWN, /*!< Lane curve model information is unknown. */
    //
    //
    LANE_CURVE_MODEL_NOT_AVAILABLE, /*!< Lane curve model information is not available. */
    //
    //
    LANE_CURVE_MODEL_LINEAR, /*!< Linear curve model. */
    //
    //
    LANE_CURVE_MODEL_PARABOLIC, /*!< Parabolic curve model. */
    //
    //
    LANE_CURVE_MODEL_3D, /*!< Third-degree curve model. */
    //
    //
    LANE_CURVE_MODEL_KIND_COUNT /*!< Number of \ref ps_lane_curve_model_kind values. */
};


/**
 * @brief Traffic sign kinds.
 *
 * @note The values represent what is seen on the sign, units are provided
 * elsewhere (ie \ref ps_traffic_sign_unit_kind).
 *
 */
enum ps_traffic_sign_kind
{
    //
    //
    TRAFFIC_SIGN_INVALID, /*!< Traffic sign information is invalid. */
    //
    //
    TRAFFIC_SIGN_UNKNOWN, /*!< Traffic sign information is unknown. */
    //
    //
    TRAFFIC_SIGN_NOT_AVAILABLE, /*!< Traffic sign information is not available. */
    //
    //
    TRAFFIC_SIGN_REG_10, /*!< Standard regular 10. */
    //
    //
    TRAFFIC_SIGN_REG_20, /*!< Standard regular 20. */
    //
    //
    TRAFFIC_SIGN_REG_30, /*!< Standard regular 30. */
    //
    //
    TRAFFIC_SIGN_REG_40, /*!< Standard regular 40. */
    //
    //
    TRAFFIC_SIGN_REG_50, /*!< Standard regular 50. */
    //
    //
    TRAFFIC_SIGN_REG_60, /*!< Standard regular 60. */
    //
    //
    TRAFFIC_SIGN_REG_70, /*!< Standard regular 70. */
    //
    //
    TRAFFIC_SIGN_REG_80, /*!< Standard regular 80. */
    //
    //
    TRAFFIC_SIGN_REG_90, /*!< Standard regular 90. */
    //
    //
    TRAFFIC_SIGN_REG_100, /*!< Standard regular 100. */
    //
    //
    TRAFFIC_SIGN_REG_110, /*!< Standard regular 110. */
    //
    //
    TRAFFIC_SIGN_REG_120, /*!< Standard regular 120. */
    //
    //
    TRAFFIC_SIGN_REG_130, /*!< Standard regular 130. */
    //
    //
    TRAFFIC_SIGN_REG_140, /*!< Standard regular 140. */
    //
    //
    TRAFFIC_SIGN_REG_END_RESTRICT_NUM, /*!< Standard regular end restriction of number. */
    //
    //
    TRAFFIC_SIGN_ELE_10, /*!< Standard electronic 10. */
    //
    //
    TRAFFIC_SIGN_ELE_20, /*!< Standard electronic 20. */
    //
    //
    TRAFFIC_SIGN_ELE_30, /*!< Standard electronic 30. */
    //
    //
    TRAFFIC_SIGN_ELE_40, /*!< Standard electronic 40. */
    //
    //
    TRAFFIC_SIGN_ELE_50, /*!< Standard electronic 50. */
    //
    //
    TRAFFIC_SIGN_ELE_60, /*!< Standard electronic 60. */
    //
    //
    TRAFFIC_SIGN_ELE_70, /*!< Standard electronic 70. */
    //
    //
    TRAFFIC_SIGN_ELE_80, /*!< Standard electronic 80. */
    //
    //
    TRAFFIC_SIGN_ELE_90, /*!< Standard electronic 90. */
    //
    //
    TRAFFIC_SIGN_ELE_100, /*!< Standard electronic 100. */
    //
    //
    TRAFFIC_SIGN_ELE_110, /*!< Standard electronic 110. */
    //
    //
    TRAFFIC_SIGN_ELE_120, /*!< Standard electronic 120. */
    //
    //
    TRAFFIC_SIGN_ELE_130, /*!< Standard electronic 130. */
    //
    //
    TRAFFIC_SIGN_ELE_140, /*!< Standard electronic 140. */
    //
    //
    TRAFFIC_SIGN_ELE_END_RESTRICT_NUM, /*!< Standard electronic end restriction of number. */
    //
    //
    TRAFFIC_SIGN_REG_END_RESTRICT_ALL, /*!< Standard regular general end all restriction. */
    //
    //
    TRAFFIC_SIGN_ELE_END_RESTRICT_ALL, /*!< Standard electronic general end all restriction. */
    //
    //
    TRAFFIC_SIGN_REG_5, /*!< Standard regular 5. */
    //
    //
    TRAFFIC_SIGN_REG_15, /*!< Standard regular 15. */
    //
    //
    TRAFFIC_SIGN_REG_25, /*!< Standard regular 25. */
    //
    //
    TRAFFIC_SIGN_REG_35, /*!< Standard regular 35. */
    //
    //
    TRAFFIC_SIGN_REG_45, /*!< Standard regular 45. */
    //
    //
    TRAFFIC_SIGN_REG_55, /*!< Standard regular 55. */
    //
    //
    TRAFFIC_SIGN_REG_65, /*!< Standard regular 65. */
    //
    //
    TRAFFIC_SIGN_REG_75, /*!< Standard regular 75. */
    //
    //
    TRAFFIC_SIGN_REG_85, /*!< Standard regular 85. */
    //
    //
    TRAFFIC_SIGN_REG_95, /*!< Standard regular 95. */
    //
    //
    TRAFFIC_SIGN_REG_105, /*!< Standard regular 105. */
    //
    //
    TRAFFIC_SIGN_REG_115, /*!< Standard regular 115. */
    //
    //
    TRAFFIC_SIGN_REG_125, /*!< Standard regular 125. */
    //
    //
    TRAFFIC_SIGN_REG_135, /*!< Standard regular 135. */
    //
    //
    TRAFFIC_SIGN_REG_145, /*!< Standard regular 145. */
    //
    //
    TRAFFIC_SIGN_ELE_5, /*!< Standard electronic 5. */
    //
    //
    TRAFFIC_SIGN_ELE_15, /*!< Standard electronic 15. */
    //
    //
    TRAFFIC_SIGN_ELE_25, /*!< Standard electronic 25. */
    //
    //
    TRAFFIC_SIGN_ELE_35, /*!< Standard electronic 35. */
    //
    //
    TRAFFIC_SIGN_ELE_45, /*!< Standard electronic 45. */
    //
    //
    TRAFFIC_SIGN_ELE_55, /*!< Standard electronic 55. */
    //
    //
    TRAFFIC_SIGN_ELE_65, /*!< Standard electronic 65. */
    //
    //
    TRAFFIC_SIGN_ELE_75, /*!< Standard electronic 75. */
    //
    //
    TRAFFIC_SIGN_ELE_85, /*!< Standard electronic 85. */
    //
    //
    TRAFFIC_SIGN_ELE_95, /*!< Standard electronic 95. */
    //
    //
    TRAFFIC_SIGN_ELE_105, /*!< Standard electronic 105. */
    //
    //
    TRAFFIC_SIGN_ELE_115, /*!< Standard electronic 115. */
    //
    //
    TRAFFIC_SIGN_ELE_125, /*!< Standard electronic 125. */
    //
    //
    TRAFFIC_SIGN_ELE_135, /*!< Standard electronic 135. */
    //
    //
    TRAFFIC_SIGN_ELE_145, /*!< Standard electronic 145. */
    //
    //
    TRAFFIC_SIGN_REG_BEGIN_MOTORWAY, /*!< Standard regular begin of motorway. */
    //
    //
    TRAFFIC_SIGN_REG_END_MOTORWAY, /*!< Standard regular end of motorway. */
    //
    //
    TRAFFIC_SIGN_REG_BEGIN_EXPRESSWAY, /*!< Standard regular begin of expressway. */
    //
    //
    TRAFFIC_SIGN_REG_END_EXPRESSWAY, /*!< Standard regular end of expressway. */
    //
    //
    TRAFFIC_SIGN_REG_BEGIN_PLAYGROUND_AREA, /*!< Standard regular begin of playground area. */
    //
    //
    TRAFFIC_SIGN_REG_END_PLAYGROUND_AREA, /*!< Standard regular end of playground area. */
    //
    //
    TRAFFIC_SIGN_REG_BEGIN_NO_PASSING, /*!< Standard regular begin of no passing area. */
    //
    //
    TRAFFIC_SIGN_REG_END_NO_PASSING, /*!< Standard regular end of no passing area. */
    //
    //
    TRAFFIC_SIGN_ELE_BEGIN_NO_PASSING, /*!< Standard electronic begin of no passing area. */
    //
    //
    TRAFFIC_SIGN_ELE_END_NO_PASSING, /*!< Standard electronic end of no passing area. */
    //
    //
    TRAFFIC_SIGN_KIND_COUNT /*!< Number of \ref ps_traffic_sign_kind values. */
};


/**
 * @brief Supplementary sign kinds.
 *
 */
enum ps_supplementary_sign_kind
{
    //
    //
    SUPPLEMENTARY_SIGN_INVALID, /*!< Supplementary sign information is invalid. */
    //
    //
    SUPPLEMENTARY_SIGN_UNKNOWN, /*!< Supplementary sign information is unknown. */
    //
    //
    SUPPLEMENTARY_SIGN_NOT_AVAILABLE, /*!< Supplementary sign information is not available. */
    //
    //
    SUPPLEMENTARY_SIGN_RAIN, /*!< Rain. */
    //
    //
    SUPPLEMENTARY_SIGN_SNOW, /*!< Snow. */
    //
    //
    SUPPLEMENTARY_SIGN_TRAILER, /*!< Trailer. */
    //
    //
    SUPPLEMENTARY_SIGN_TIME, /*!< Time. */
    //
    //
    SUPPLEMENTARY_SIGN_ARROW_LEFT, /*!< Left arrow. */
    //
    //
    SUPPLEMENTARY_SIGN_ARROW_RIGHT, /*!< Right arrow. */
    //
    //
    SUPPLEMENTARY_SIGN_BEND_ARROW_LEFT, /*!< Left bent arrow. */
    //
    //
    SUPPLEMENTARY_SIGN_BEND_ARROW_RIGHT, /*!< Right bent arrow. */
    //
    //
    SUPPLEMENTARY_SIGN_TRUCK, /*!< Truck. */
    //
    //
    SUPPLEMENTARY_SIGN_DISTANCE_ARROW, /*!< Distance arrow, restriction is for x kilometers. */
    //
    //
    SUPPLEMENTARY_SIGN_WEIGHT, /*!< Weight. */
    //
    //
    SUPPLEMENTARY_SIGN_DISTANCE_IN, /*!< Disance in, restriction in x meters. */
    //
    //
    SUPPLEMENTARY_SIGN_TRACTOR, /*!< Tractor. */
    //
    //
    SUPPLEMENTARY_SIGN_SNOW_RAIN, /*!< Snow/rain. */
    //
    //
    SUPPLEMENTARY_SIGN_SCHOOL, /*!< School. */
    //
    //
    SUPPLEMENTARY_SIGN_RAIN_CLOUD, /*!< Rain cloud. */
    //
    //
    SUPPLEMENTARY_SIGN_FOG, /*!< Fog. */
    //
    //
    SUPPLEMENTARY_SIGN_HAZARDOUS_MATERIALS, /*!< Hazardous materials. */
    //
    //
    SUPPLEMENTARY_SIGN_NIGHT, /*!< Night. */
    //
    //
    SUPPLEMENTARY_SIGN_RAPPEL, /*!< Rappel. */
    //
    //
    SUPPLEMENTARY_SIGN_E_ZONE, /*!< Zone word below the sign. */
    //
    //
    SUPPLEMENTARY_SIGN_KIND_COUNT /*!< Number of \ref ps_supplementary_sign_kind values. */
};


/**
 * @brief Traffic sign unit kinds.
 *
 */
enum ps_traffic_sign_unit_kind
{
    //
    //
    TRAFFIC_SIGN_UNIT_INVALID, /*!< Traffic sign unit information is invalid. */
    //
    //
    TRAFFIC_SIGN_UNIT_UNKNOWN, /*!< Traffic sign unit information is unknown. */
    //
    //
    TRAFFIC_SIGN_UNIT_NOT_AVAILABLE, /*!< Traffic sign unit information is not available. */
    //
    //
    TRAFFIC_SIGN_UNIT_MPH, /*!< Traffic sign units are in miles per hour. */
    //
    //
    TRAFFIC_SIGN_UNIT_KPH, /*!< Traffic sign units are in kilometers per hour. */
    //
    //
    TRAFFIC_SIGN_UNIT_KIND_COUNT /*!< Number of \ref ps_traffic_sign_unit_kind values. */
};


/**
 * @brief GPS fix kinds.
 *
 */
enum ps_gps_fix_kind
{
    //
    //
    GPS_FIX_INVALID, /*!< GPS fix information is invalid. */
    //
    //
    GPS_FIX_UNKNOWN, /*!< GPS fix information is unknown. */
    //
    //
    GPS_FIX_NOT_AVAILABLE, /*!< GPS fix information is not available. */
    //
    //
    GPS_FIX_NONE, /*!< No GPS fix. */
    //
    //
    GPS_FIX_2D, /*!< 2D GPS fix. */
    //
    //
    GPS_FIX_3D, /*!< 3D GPS fix. */
    //
    //
    GPS_FIX_KIND_COUNT /*!< Number of \ref ps_gps_fix_kind values. */
};


/**
 * @brief Zone alert kinds.
 *
 */
enum ps_zone_alert_kind
{
    //
    //
    ZONE_ALERT_INVALID, /*!< Zone alert information is invalid. */
    //
    //
    ZONE_ALERT_UNKNOWN, /*!< Zone alert information is unknown. */
    //
    //
    ZONE_ALERT_NOT_AVAILABLE, /*!< Zone alert information is not available. */
    //
    //
    ZONE_ALERT_NONE, /*!< No Zone alert. */
    //
    //
    ZONE_ALERT_WARNING, /*!< Zone alert warning. */
    //
    //
    ZONE_ALERT_ALARM, /*!< Zone alert alarm. */
    //
    //
    ZONE_ALERT_KIND_COUNT /*!< Number of \ref ps_zone_alert_kind values. */
 };


/**
 * @brief GPS heading quality kinds.
 *
 */
enum ps_gps_heading_quality_kind
{
    //
    //
    HEADING_QUALITY_INVALID, /*!< GPS heading quality information is invalid. */
    //
    //
    HEADING_QUALITY_UNKNOWN, /*!< GPS heading quality information is unknown. */
    //
    //
    HEADING_QUALITY_NOT_AVAILABLE, /*!< GPS heading quality information is not available. */
    //
    //
    HEADING_QUALITY_POOR, /*!< Heading information is unusable. */
    //
    //
    HEADING_QUALITY_RTK_FLOAT, /*!< Floating ambiguity heading solution. */
    //
    //
    HEADING_QUALITY_RTK_INTEGER, /*!< Integer ambiguity heading solution. */
    //
    //
    HEADING_QUALITY_KIND_COUNT /*!< Number of \ref ps_gps_heading_quality_kind values. */
};


/**
 * @brief GPS heading search kinds.
 *
 */
enum ps_gps_heading_search_kind
{
    //
    //
    HEADING_SEARCH_INVALID, /*!< GPS heading search information is invalid. */
    //
    //
    HEADING_SEARCH_UNKNOWN, /*!< GPS heading search information is unknown. */
    //
    //
    HEADING_SEARCH_NOT_AVAILABLE, /*!< GPS heading search information is not available. */
    //
    //
    HEADING_SEARCH_IDLE, /*!< Not searching at the moment. */
    //
    //
    HEADING_SEARCH_L1, /*!< Using L1 frequency for ambiguity resolution. */
    //
    //
    HEADING_SEARCH_L2, /*!< Using L2 frequency for ambiguity resolution. */
    //
    //
    HEADING_SEARCH_L1L2, /*!< Using L1 and L2 frequencies for ambiguity resolution. */
    //
    //
    HEADING_SEARCH_KIND_COUNT /*!< Number of \ref ps_gps_heading_search_kind values. */
};




// *****************************************************
// data structures
// *****************************************************

/**
 * @brief Standard sensor descriptor.
 *
 * Identifies a sensor and describes its coordinate frame.
 *
 */
struct ps_sensor_descriptor
{
    //
    //
    ps_identifier               id; /*!< Identifier, in most cases this is the serial number.
                                     * Value \ref PSYNC_SENSOR_ID_INVALID means invalid. */
    //
    //
    ps_sensor_kind              type; /*!< PolySync sensor type.
                                       * Value \ref PSYNC_SENSOR_KIND_INVALID means invalid.
                                       * Value \ref PSYNC_SENSOR_KIND_NOT_AVAILABLE means type not available. */
    //
    //
    ps_transform_stack          transform; /*!< Transform that describes this data's coordinate frame. */
};


/**
 * @brief Generic 3D Lidar point.
 *
 * Describes a Lidar point in 3D space.
 *
 * All coordinate data is in the parent frame, see \ref ps_sensor_descriptor.
 *
 * @note The position data is stored as a float instead of the standard double type.
 *
 */
struct ps_lidar_point
{
    //
    //
    float                       position[3]; /*!< Position of point.
                                              * Value \ref PSYNC_FLOAT_POSITION_NOT_AVAILABLE means given axis component not available. [xyz meters] */
    //
    //
    octet                       intensity; /*!< Intensity of point.
                                            * Value zero means intensity not known or not available.
                                            * Value one means lowest intensity.
                                            * Value 255 (0xFF) means highest intensity. */
};


/**
 * @brief Radar provided target.
 *
 * Describes a target or track being estimated based on Radar data.
 *
 * Validity is determined using the \ref ps_radar_target.track_status value.
 *
 * All coordinate data is in the parent frame, see \ref ps_sensor_descriptor.
 *
 */
struct ps_radar_target
{
    //
    //
    ps_identifier               id;  /*!< Identifier. If this is a track, this provides the track identifier.  */
    //
    //
    ps_timestamp                timestamp; /*!< Last update timestamp. [microseconds]
                                            *
                                            * PolySync drivers will set this to
                                            * the last receive update time
                                            * in the now time domain during
                                            * record mode, or the replay time
                                            * domain during replay mode. */
    //
    //
    ps_native_timestamp         native_timestamp; /*!< Native timestamp associated with the last update.
                                                   * Provided by some devices.
                                                   * Check \ref ps_native_timestamp.format for meaning.
                                                   * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    double                      position[3]; /*!< Position of target.
                                              * Value \ref PSYNC_POSITION_NOT_AVAILABLE means given axis component not available. [xyz meters] */
    //
    //
    double                      size[3]; /*!< Size of target.
                                          * Value \ref PSYNC_SIZE_NOT_AVAILABLE means given axis component not available. [xyz meters] */
    //
    //
    double                      velocity[3]; /*!< Velocity of target.
                                              * Value \ref PSYNC_VELOCITY_NOT_AVAILABLE means given axis component not available. [xyz meters/second] */
    //
    //
    double                      range_rate; /*!< Range rate (or sometimes the Doppler velocity) of target.
                                             * Value \ref PSYNC_VELOCITY_NOT_AVAILABLE means not available. [meters/second] */
    //
    //
    ps_track_status_kind        track_status; /*!< If this target is a track, this provides its status if supported.
                                               * Value \ref TRACK_STATUS_RAW_TARGET means this is a raw target/measurement and not a track. */
    //
    //
    ps_range_kind               range_type; /*!< Target range type. */
    //
    //
    ps_zone_kind                zone_type; /*!< Target zone type. */
    //
    //
    ps_quality_kind             quality; /*!< Target quality. */
    //
    //
    double                      amplitude; /*!< Target amplitude.
                                            * Value \ref PSYNC_AMPLITUDE_NOT_AVAILABLE means not available. [decibels] */
    //
    //
    double                      magnitude; /*!< Target magnitude.
                                            * Value \ref PSYNC_MAGNITUDE_NOT_AVAILABLE means not available. [decibels] */
    //
    //
    double                      alias; /*!< Target range rate alias (or sometimes the Doppler alias) of target relative to the parent coordinate frame.
                                        * Value \ref PSYNC_VELOCITY_ALIAS_NOT_AVAILABLE means not available. [meters/second] */
    //
    //
    double                      cross_section; /*!< Target radar cross section.
                                                * Value \ref PSYNC_RADAR_CROSS_SECTION_NOT_AVAILABLE means not available. [meters^2]  */
    //
    //
    unsigned long               scan_index; /*!< Target scan index.
                                             * Value zero means unknown or not available. */
};


/**
 * @brief Generic spatial object.
 *
 * Describes a generic spatial object.
 *
 * All coordinate data is in the parent frame, see \ref ps_sensor_descriptor.
 *
 */
struct ps_object
{
    //
    //
    ps_identifier               id;  /*!< Identifier from tracking.  */
    //
    //
    ps_timestamp                timestamp; /*!< Last update timestamp. [microseconds]
                                            *
                                            * PolySync drivers will set this to
                                            * the last receive update time
                                            * in the now time domain during
                                            * record mode, or the replay time
                                            * domain during replay mode. */
    //
    //
    ps_native_timestamp         native_timestamp; /*!< Native timestamp associated with the last update.
                                                   * Provided by some devices.
                                                   * Check \ref ps_native_timestamp.format for meaning.
                                                   * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    double                      position[3]; /*!< Position of object.
                                              * Value \ref PSYNC_POSITION_NOT_AVAILABLE means given axis component not available. [xyz meters] */
    //
    //
    double                      size[3]; /*!< Size of object.
                                          * Value \ref PSYNC_SIZE_NOT_AVAILABLE means given axis component not available. [xyz meters] */
    //
    //
    double                      velocity[3]; /*!< Velocity of object.
                                              * Value \ref PSYNC_VELOCITY_NOT_AVAILABLE means given axis component not available. [xyz meters/second] */
    //
    //
    double                      course_angle; /*!< Orientation/heading of the object.
                                               * Value \ref PSYNC_HEADING_NOT_AVAILABLE means value not available. [radians] */
    //
    //
    ps_object_classification_kind classification; /*!< Most likely classification of the object. */
    //
    //
    ps_quality_kind             classification_quality; /*!< Classification quality. The higher the quality, the more reliable the object classification is. */
};


/**
 * @brief Lane model.
 *
 * Describes a lane model.
 *
 * Validity is determined using the \ref ps_lane_model.quality value.
 *
 * All coordinate data is in the parent frame, see \ref ps_sensor_descriptor.
 *
 * \n
 *
 * Coefficients used in the formulas for handling lane model data are conditioned:
 * \li \f$C_0 = (\f$ \ref ps_lane_model.marker_offset \f$)\f$ - conditioned lane position
 * \li \f$C_1 = (\f$ \ref ps_lane_model.heading_angle \f$)\f$ - conditioned lane heading angle
 * \li \f$C_2 = (\f$ \ref ps_lane_model.curvature \f$) / 2.0\f$ - conditioned lane curvature
 * \li \f$C_2 = (\f$ \ref ps_lane_model.curvature_derivative \f$) / 6.0\f$ - conditioned lane curvature derivative
 *
 * \n
 *
 * Formula for deriving lateral (y) distance from longitudinal (x) distance:
 * \li Model type: \ref LANE_CURVE_MODEL_3D
 *   - \f$Y = (C_3 \times X^3) + (C_2 \times X^2) + (C_1 \times X) + C_0\f$
 * \li Model type: \ref LANE_CURVE_MODEL_PARABOLIC
 *   - \f$Y = (C_2 \times X^2) + (C_1 \times X) + C_0\f$
 *
 * \n
 *
 * Formula for lane marker curvature at longitudinal distance (x):
 * \li Model type: \ref LANE_CURVE_MODEL_3D
 *   - \f$Curvature(X) = (\f$ \ref ps_lane_model.curvature \f$) + (\f$ \ref ps_lane_model.curvature_derivative \f$ \times X)\f$
 *
 * \n
 *
 * Formulate for road radius (r) from curvature:
 * \li \f$r = 1 / (\f$ \ref ps_lane_model.curvature \f$)\f$
 *
 */
struct ps_lane_model
{
    //
    //
    ps_timestamp                timestamp; /*!< Last update timestamp. [microseconds]
                                            *
                                            * PolySync drivers will set this to
                                            * the last receive update time
                                            * in the now time domain during
                                            * record mode, or the replay time
                                            * domain during replay mode. */
    //
    //
    ps_native_timestamp         native_timestamp; /*!< Native timestamp associated with the last update.
                                                   * Provided by some devices.
                                                   * Check \ref ps_native_timestamp.format for meaning.
                                                   * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    ps_quality_kind             quality; /*!< Detection quality for the lane, used to indicate lane validity.
                                          * Value \ref QUALITY_INVALID means lane is invalid. */
    //
    //
    ps_lane_marker_kind         marker_type; /*!< Marker/boundary type.
                                              * Value \ref LANE_MARKER_UNKNOWN means undecided. */
    //
    //
    ps_lane_curve_model_kind    model_type; /*!< Lane curve model type. */
    //
    //
    double                      marker_width; /*!< Marker width.
                                               * Value \ref PSYNC_SIZE_NOT_AVAILABLE means not available. [meters] */
    //
    //
    double                      heading_angle; /*!< Angle of the marker.
                                                * Value \ref PSYNC_HEADING_NOT_AVAILABLE means value not available. [radians] */
    //
    //
    double                      view_range; /*!< Visible range of the marker.
                                             * Value \ref PSYNC_POSITION_NOT_AVAILABLE means not available. [meters] */
    //
    //
    double                      marker_offset; /*!< Lateral position/offset of the marker.
                                                * Value \ref PSYNC_POSITION_NOT_AVAILABLE means not available. [meters] */
    //
    //
    double                      curvature; /*!< Curvature of the lane.
                                            * Value \ref PSYNC_HEADING_NOT_AVAILABLE means not available. [1/meters] */
    //
    //
    double                      curvature_derivative; /*!< Curvature derivative of the lane.
                                                       * Value \ref PSYNC_HEADING_NOT_AVAILABLE means not available. [1/meters^2] */
    //
    //
    ps_timestamp                time_to_crossing; /*!< Time to lane crossing.
                                                   * Value zero means not valid. [microseconds] */
};


/**
 * @brief Traffic sign.
 *
 * Describes a traffic sign.
 *
 * All coordinate data is in the parent frame, see \ref ps_sensor_descriptor.
 *
 */
struct ps_traffic_sign
{
    //
    //
    ps_timestamp                timestamp; /*!< Last update timestamp. [microseconds]
                                            *
                                            * PolySync drivers will set this to
                                            * the last receive update time
                                            * in the now time domain during
                                            * record mode, or the replay time
                                            * domain during replay mode. */
    //
    //
    ps_native_timestamp         native_timestamp; /*!< Native timestamp associated with the last update.
                                                   * Provided by some devices.
                                                   * Check \ref ps_native_timestamp.format for meaning.
                                                   * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    ps_traffic_sign_kind        type; /*!< Sign type.
                                       * Value \ref TRAFFIC_SIGN_INVALID means no sign detected. */
    //
    //
    ps_supplementary_sign_kind  supplementary_type; /*!< Supplementary type associated with the sign.
                                                     * Value \ref SUPPLEMENTARY_SIGN_NOT_AVAILABLE means not available. */
    //
    //
    ps_traffic_sign_unit_kind   speed_units; /*!< Traffic sign units. */
    //
    //
    double                      position[3]; /*!< Position of the sign.
                                              * Value \ref PSYNC_POSITION_NOT_AVAILABLE means given axis component not available. [xyz meters] */
};


/**
 * @brief Generic 2-D zone.
 *
 * Validity is determined using the \ref ps_zone.quality value.
 *
 * Describes a measurement zone.
 *
 * All coordinate data is in the parent frame, see \ref ps_sensor_descriptor.
 *
 */
struct ps_zone
{
    //
    //
    ps_identifier id;  /*!< Zone identifier.  */
    //
    //
    ps_timestamp timestamp; /*!< Last update timestamp. [microseconds]
                             *
                             * PolySync drivers will set this to
                             * the last receive update time
                             * in the now time domain during
                             * record mode, or the replay time
                             * domain during replay mode. */
    //
    //
    ps_native_timestamp native_timestamp; /*!< Native timestamp associated with the last update.
                                           * Provided by some devices.
                                           * Check \ref ps_native_timestamp.format for meaning.
                                           * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    ps_zone_alert_kind zone_alert_kind; /*!< Alert kind.
                                         * Value \ref ZONE_ALERT_NONE means no alert. */
    //
    //
    double distances[2]; /*!< Start and end distances of zone. [meters]
                          * Value \ref PSYNC_POSITION_NOT_AVAILABLE means not available. */
    //
    //
    double horizontal_angles[2]; /*!< Start and end x-y horizontal angles of zone. [radians]
                                  * Value \ref PSYNC_ANGLE_NOT_AVAILABLE means not available. */
    //
    //
    double vertical_angles[2]; /*!< Start and end x-z vertical angles of zone. [radians]
                                * Value \ref PSYNC_ANGLE_NOT_AVAILABLE means not available. */
    //
    //
    double origin[3]; /*!< Cartesian coordinates of zone origin. [xyz]
                       * Value \ref PSYNC_POSITION_NOT_AVAILABLE means not available. */
    //
    //
    double orientation[4]; /*!< Orientation quaternion. [xyzw quaternion]
                            * Value \ref PSYNC_ORIENTATION_NOT_AVAILABLE means not available. */
    //
    //
    ps_quality_kind quality; /*!< Zone measurement quality. */
 };



// *****************************************************
// message types
// *****************************************************


/**
 * @brief Image data message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_image_data_msg
{
    //
    //
    ps_msg_header               header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor        sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp                timestamp; /*!< Image timestamp. [microseconds]
                                            *
                                            * PolySync drivers will set this to
                                            * the last receive update time
                                            * in the now time domain during
                                            * record mode, or the replay time
                                            * domain during replay mode. */
    //
    //
    ps_native_timestamp         native_timestamp; /*!< Native timestamp for the image.
                                                   * Provided by some devices.
                                                   * Check \ref ps_native_timestamp.format for meaning.
                                                   * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    ps_pixel_format_kind        pixel_format; /*!< Image data format. */
    //
    //
    ps_identifier               frame_id; /*!< Image counter.
                                           * Value \ref PSYNC_IDENTIFIER_INVALID means not available. */
    //
    //
    unsigned short              width; /*!< Image width. [pixels] */
    //
    //
    unsigned short              height; /*!< Image height. [pixels] */
    //
    //
    sequence<octet>             data_buffer; /*!< Image data buffer. */
};
///@cond INTERNAL
#pragma keylist ps_image_data_msg header.src_guid
#pragma expose ps_image_data_msg
///@endcond


/**
 * @brief Platform motion message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_motion_msg
{
    //
    //
    ps_msg_header               header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor        sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp                timestamp; /*!< Sample timestamp. [microseconds]
                                            *
                                            * PolySync drivers will set this to
                                            * the last receive update time
                                            * in the now time domain during
                                            * record mode, or the replay time
                                            * domain during replay mode. */
    //
    //
    ps_native_timestamp         native_timestamp; /*!< Native timestamp for the motion data sample.
                                                   * Provided by some devices.
                                                   * Check \ref ps_native_timestamp.format for meaning.
                                                   * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    double                      position[3]; /*!< Position.
                                              * Value \ref PSYNC_POSITION_NOT_AVAILABLE means given axis component not available. [xyz meters] */
    //
    //
    double                      orientation[4]; /*!< Orientation quaternion.
                                                   * Value \ref PSYNC_ORIENTATION_NOT_AVAILABLE means given axis component not available. [xyzw quaternion] */
    //
    //
    double                      rotation_rate[3]; /*!< Rotation rate.
                                                   * Value \ref PSYNC_ROTATION_RATE_NOT_AVAILABLE means given axis component not available. [xyz radians/second] */
    //
    //
    double                      velocity[3]; /*!< Velocity.
                                              * Value \ref PSYNC_VELOCITY_NOT_AVAILABLE means given axis component not available. [xyz meters/second] */
    //
    //
    double                      acceleration[3]; /*!< Acceleration.
                                                  * Value \ref PSYNC_ACCELERATION_NOT_AVAILABLE means given axis component not available. [xyz meters/second^2] */
    //
    //
    double                      heading; /*!< Heading angle, 0 radians equals North.
                                          * Value \ref PSYNC_HEADING_NOT_AVAILABLE means not available. [radians] */
    //
    //
    double                      latitude; /*!< Latitude.
                                           * Value \ref PSYNC_LATITUDE_NOT_AVAILABLE means not available. [radians] */
    //
    //
    double                      longitude; /*!< Longitude.
                                            * Value \ref PSYNC_LONGITUDE_NOT_AVAILABLE means not available. [radians] */
    //
    //
    double                      altitude; /*!< Longitude.
                                           * Value \ref PSYNC_ALTITUDE_NOT_AVAILABLE means not available. [meters] */
};
///@cond INTERNAL
#pragma keylist ps_platform_motion_msg header.src_guid
#pragma expose ps_platform_motion_msg
///@endcond


/**
 * @brief IMU message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_imu_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Sample timestamp. [microseconds]
                             *
                             * PolySync drivers will set this to
                             * the last receive update time
                             * in the now time domain during
                             * record mode, or the replay time
                             * domain during replay mode. */
    //
    //
    ps_native_timestamp native_timestamp; /*!< Native timestamp for the motion data sample.
                                           * Provided by some devices.
                                           * Check \ref ps_native_timestamp.format for meaning.
                                           * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    double orientation[4]; /*!< Orientation quaternion.
                            * Value \ref PSYNC_ORIENTATION_NOT_AVAILABLE means given axis component not available. [xyzw quaternion] */
    //
    //
    double rotation_rate[3]; /*!< Rotation rate.
                              * Value \ref PSYNC_ROTATION_RATE_NOT_AVAILABLE means given axis component not available. [xyz radians/second] */
    //
    //
    double velocity[3]; /*!< Velocity.
                         * Value \ref PSYNC_VELOCITY_NOT_AVAILABLE means given axis component not available. [xyz meters/second] */
    //
    //
    double acceleration[3]; /*!< Acceleration.
                             * Value \ref PSYNC_ACCELERATION_NOT_AVAILABLE means given axis component not available. [xyz meters/second^2] */
};
///@cond INTERNAL
#pragma keylist ps_imu_msg header.src_guid
#pragma expose ps_imu_msg
///@endcond


/**
 * @brief GPS message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_gps_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Sample timestamp. [microseconds]
                             *
                             * PolySync drivers will set this to
                             * the last receive update time
                             * in the now time domain during
                             * record mode, or the replay time
                             * domain during replay mode. */
    //
    //
    ps_native_timestamp native_timestamp; /*!< Native timestamp for the motion data sample.
                                           * Provided by some devices.
                                           * Check \ref ps_native_timestamp.format for meaning.
                                           * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    double heading; /*!< Heading angle.
                     * Zero radians equals North.
                     * Value \ref PSYNC_HEADING_NOT_AVAILABLE means not available. [radians] */
    //
    //
    double latitude; /*!< Latitude.
                      * Value \ref PSYNC_LATITUDE_NOT_AVAILABLE means not available. [radians] */
    //
    //
    double longitude; /*!< Longitude.
                       * Value \ref PSYNC_LONGITUDE_NOT_AVAILABLE means not available. [radians] */
    //
    //
    double altitude; /*!< Longitude.
                      * Value \ref PSYNC_ALTITUDE_NOT_AVAILABLE means not available. [meters] */
    //
    //
    double speed; /*!< Speed over ground.
                      * Value \ref PSYNC_VELOCITY_NOT_AVAILABLE means not available. [meters] */
    //
    //
    octet satellite_count; /*!< Number of satellites. */
    //
    //
    ps_gps_fix_kind fix; /*!< Fix kind.
                          * Value \ref GPS_FIX_NONE means no fix. */
};
///@cond INTERNAL
#pragma keylist ps_gps_msg header.src_guid
#pragma expose ps_gps_msg
///@endcond


/**
 * @brief Radar targets message.
 *
 * Contains a buffer of \ref ps_radar_target data.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_radar_targets_msg
{
    //
    //
    ps_msg_header               header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor        sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    sequence<ps_radar_target>   targets;  /*!< Radar targets. */
};
///@cond INTERNAL
#pragma keylist ps_radar_targets_msg header.src_guid
#pragma expose ps_radar_targets_msg
///@endcond


/**
 * @brief Generic Lidar points message.
 *
 * Contains a buffer of \ref ps_lidar_point data.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_lidar_points_msg
{
    //
    //
    ps_msg_header               header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor        sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp                start_timestamp; /*!< Scan start timestamp. [microseconds]
                                                  *
                                                  * PolySync drivers will set this to
                                                  * the last receive update time
                                                  * (of the first data packet in the scan)
                                                  * in the now time domain during
                                                  * record mode, or the replay time
                                                  * domain during replay mode. */
    //
    //
    ps_timestamp                end_timestamp; /*!< Scan end timestamp. [microseconds]
                                                *
                                                * PolySync drivers will set this to
                                                * the last receive update time
                                                * (of the last data packet in the scan)
                                                * in the now time domain during
                                                * record mode, or the replay time
                                                * domain during replay mode. */
    //
    //
    ps_native_timestamp         native_start_timestamp; /*!< Native timestamp for the scan start.
                                                         * Provided by some devices.
                                                         * Check \ref ps_native_timestamp.format for meaning.
                                                         * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    sequence<ps_lidar_point>    points;  /*!< Lidar points. */
};
///@cond INTERNAL
#pragma keylist ps_lidar_points_msg header.src_guid
#pragma expose ps_lidar_points_msg
///@endcond


/**
 * @brief Objects message.
 *
 * Contains a buffer of \ref ps_object data.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_objects_msg
{
    //
    //
    ps_msg_header               header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor        sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    sequence<ps_object>         objects;  /*!< Objects. */
};
///@cond INTERNAL
#pragma keylist ps_objects_msg header.src_guid
#pragma expose ps_objects_msg
///@endcond


/**
 * @brief Lane model message.
 *
 * Contains a buffer of \ref ps_lane_model data.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_lane_model_msg
{
    //
    //
    ps_msg_header               header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor        sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    sequence<ps_lane_model>     lanes;  /*!< Lane models. */
};
///@cond INTERNAL
#pragma keylist ps_lane_model_msg header.src_guid
#pragma expose ps_lane_model_msg
///@endcond


/**
 * @brief Traffic sign message.
 *
 * Contains a buffer of \ref ps_traffic_sign data.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_traffic_sign_msg
{
    //
    //
    ps_msg_header               header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor        sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    sequence<ps_traffic_sign>   signs;  /*!< Traffic signs. */
};
///@cond INTERNAL
#pragma keylist ps_traffic_sign_msg header.src_guid
#pragma expose ps_traffic_sign_msg
///@endcond


/**
 * @brief Zone message.
 *
 * Contains a buffer of \ref ps_zone.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_zones_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp start_timestamp; /*!< The time at which the start of measurement occurred. [microseconds]
                                    * Value zero means not available. */
    //
    //
    ps_timestamp end_timestamp; /*!< The time at which the end of measurement occurred. [microseconds]
                                 * Value zero means not available. */
    //
    //
    ps_native_timestamp native_start_timestamp; /*!< Native timestamp for the scan start.
                                                 * Provided by some devices.
                                                 * Check \ref ps_native_timestamp.format for meaning.
                                                 * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    sequence<ps_zone> zones;  /*!< Zones. */
};
///@cond INTERNAL
#pragma keylist ps_zones_msg header.src_guid
#pragma expose ps_zones_msg


/**
 * @brief Global positioning system (GPS) accuracy message.
 *
 * The \ref ps_gps_accuracy_msg.header.timestamp (\ref ps_msg_header.timestamp) stores the publish timestamp (updated by the publishing node).
 *
 * Arbitration key member(s):
 * \li ps_gps_accuracy_msg.header.src_guid (\ref ps_msg_header.src_guid)
 * \li ps_gps_accuracy_msg.sensor_descriptor.id (\ref ps_sensor_descriptor.id)
 *
 */
struct ps_gps_accuracy_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Last update timestamp. [microseconds]
                             *
                             * PolySync drivers will set this to
                             * the last receive update time
                             * in the now time domain during
                             * record mode, or the replay time
                             * domain during replay mode. */
    //
    //
    ps_native_timestamp native_timestamp; /*!< Native timestamp associated with the last update.
                                           * Provided by some devices.
                                           * Check \ref ps_native_timestamp.format for meaning.
                                           * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    ps_gps_heading_quality_kind heading_quality; /*!< Heading quality.
                                                  * Value \ref HEADING_QUALITY_NOT_AVAILABLE means no heading information available. */
    //
    //
    ps_gps_heading_search_kind heading_search_type; /*!< Heading search type.
                                                  * Value \ref HEADING_SEARCH_NOT_AVAILABLE means no heading search information available. */
    //
    //
    double hdop; /*!< Horizontal dilution of precision.
                  * Value \ref PSYNC_POSITION_NOT_AVAILABLE means not available. */
    //
    //
    double vdop; /*!< Vertical dilution of precision.
                  * Value \ref PSYNC_POSITION_NOT_AVAILABLE means not available. */
    //
    //
    double pdop; /*!< Positional dilution of precision.
                  * Value \ref PSYNC_POSITION_NOT_AVAILABLE means not available. */
    //
    //
    double undulation; /*!< Difference between altitude and WGS-84 ellipsoidal altitude.
                        * Value \ref PSYNC_ALTITUDE_NOT_AVAILABLE means not available. [meters] */
    //
    //
    double enu_position_accuracy[3]; /*!< East-North-Up position accuracy.
                                      * Value \ref PSYNC_POSITION_NOT_AVAILABLE means given axis component not available. [ENU meters] */
    //
    //
    double enu_velocity_accuracy[3]; /*!< East-North-Up velocity accuracy.
                                      * Value \ref PSYNC_VELOCITY_NOT_AVAILABLE means given axis component not available. [ENU meters/second] */
    //
    //
    double heading_accuracy; /*!< Heading (yaw) angle accuracy.
                              * Value \ref PSYNC_ORIENTATION_NOT_AVAILABLE means not available. [radians] */
};
///@cond INTERNAL
#pragma keylist ps_gps_accuracy_msg header.src_guid, sensor_descriptor.id
#pragma expose ps_gps_accuracy_msg
///@endcond


/**
 * @brief Inertial measurement unit (IMU) accuracy message.
 *
 * The \ref ps_imu_accuracy_msg.header.timestamp (\ref ps_msg_header.timestamp) stores the publish timestamp (updated by the publishing node).
 *
 * Arbitration key member(s):
 * \li ps_imu_accuracy_msg.header.src_guid (\ref ps_msg_header.src_guid)
 * \li ps_imu_accuracy_msg.sensor_descriptor.id (\ref ps_sensor_descriptor.id)
 *
 */
struct ps_imu_accuracy_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Last update timestamp. [microseconds]
                             *
                             * PolySync drivers will set this to
                             * the last receive update time
                             * in the now time domain during
                             * record mode, or the replay time
                             * domain during replay mode. */
    //
    //
    ps_native_timestamp native_timestamp; /*!< Native timestamp associated with the last update.
                                           * Provided by some devices.
                                           * Check \ref ps_native_timestamp.format for meaning.
                                           * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    double velocity_accuracy[3]; /*!< Velocity accuracy.
                                  * Value \ref PSYNC_VELOCITY_NOT_AVAILABLE means given axis component not available. [meters/second] */
    //
    //
    double orientation_accuracy[3]; /*!< Orientation roll-pitch-yaw accuracy.
                                     * Value \ref PSYNC_ORIENTATION_NOT_AVAILABLE means given axis component not available. [xyz radians] */
    //
    //
    double rotation_rate_bias[3]; /*!< Rotation rate (gyroscope) bias.
                                   * Value \ref PSYNC_ROTATION_RATE_NOT_AVAILABLE means given axis component not available. [xyz radians/second] */
    //
    //
    double rotation_rate_bias_accuracy[3]; /*!< Rotation rate (gyroscope) bias accuracy.
                                            * Value \ref PSYNC_ROTATION_RATE_NOT_AVAILABLE means given axis component not available. [xyz radians/second] */
    //
    //
    double rotation_rate_scale[3]; /*!< Rotation rate (gyroscope) scale factor.
                                    * Value \ref PSYNC_ROTATION_RATE_NOT_AVAILABLE means given axis component not available. [xyz 1.0 == %100] */
    //
    //
    double rotation_rate_scale_accuracy[3]; /*!< Rotation rate (gyroscope) scale factor accuracy.
                                             * Value \ref PSYNC_ROTATION_RATE_NOT_AVAILABLE means given axis component not available. [xyz 1.0 == %100] */
    //
    //
    double acceleration_bias[3]; /*!< Accelerometer bias.
                                  * Value \ref PSYNC_ACCELERATION_NOT_AVAILABLE means given axis component not available. [xyz meters/second^2] */
    //
    //
    double acceleration_bias_accuracy[3]; /*!< Accelerometer bias accuracy.
                                           * Value \ref PSYNC_ACCELERATION_NOT_AVAILABLE means given axis component not available. [xyz meters/second^2] */
};
///@cond INTERNAL
#pragma keylist ps_imu_accuracy_msg header.src_guid, sensor_descriptor.id
#pragma expose ps_imu_accuracy_msg
///@endcond


/**
 * @brief Platform OBD message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_obd_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Last update timestamp. [microseconds]
                             *
                             * PolySync drivers will set this to
                             * the last receive update time
                             * in the now time domain during
                             * record mode, or the replay time
                             * domain during replay mode. */
    //
    //
    ps_native_timestamp native_timestamp; /*!< Native timestamp for the OBD data.
                                           * Provided by some devices.
                                           * Check \ref ps_native_timestamp.format for meaning.
                                           * Format value \ref PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID means not available. */
    //
    //
    ps_identifier pid; /*!< PID (Parameter ID) of OBD response. */
    //
    //
    ps_parameter_value data;  /*!< Value of OBD response corresponding to the PID. */
};
///@cond INTERNAL
#pragma keylist ps_platform_obd_msg header.src_guid, pid
#pragma expose ps_platform_obd_msg
///@endcond
/**
 * @file navigation.idl
 * @brief PolySync Data Model Navigation Module.
 *
 */




/**
 * @brief Navigation module major version. [uint8_t]
 *
 * Indicates a major release version.
 *
 */
const octet                 NAVIGATION_MODULE_VERSION_MAJOR         = 2;


/**
 * @brief Navigation module minor version. [uint8_t]
 *
 * Indicates a minor release version.
 * Increased each time the syntax of the module
 * is changed (ie new or removed messages, new or removed message fields, changed number of bits, etc).
 *
 */
const octet                 NAVIGATION_MODULE_VERSION_MINOR         = 0;


/**
 * @brief Navigation module sub-minor version. [uint16_t]
 *
 * Indicates a sub-minor release version.
 * Increased each time the semantics of the
 * data model are modified (ie interpretation of field values or similar).
 *
 */
const unsigned short        NAVIGATION_MODULE_VERSION_SUBMINOR      = 0;
/**
 * @file control.idl
 * @brief PolySync Data Model Control Module.
 *
 * All timestamps are in the standard UTC microsecond time domain unless
 * otherwise specified.
 *
 */




/**
 * @brief Control module major version. [uint8_t]
 *
 * Indicates a major release version.
 *
 */
const octet CONTROL_MODULE_VERSION_MAJOR = 2;


/**
 * @brief Control module minor version. [uint8_t]
 *
 * Indicates a minor release version.
 * Increased each time the syntax of the module
 * is changed (ie new or removed messages, new or removed message fields, changed number of bits, etc).
 *
 */
const octet CONTROL_MODULE_VERSION_MINOR = 0;


/**
 * @brief Control module sub-minor version. [uint16_t]
 *
 * Indicates a sub-minor release version.
 * Increased each time the semantics of the
 * data model are modified (ie interpretation of field values or similar).
 *
 */
const unsigned short CONTROL_MODULE_VERSION_SUBMINOR = 1;




// *****************************************************
// constants
// *****************************************************


/**
 * @brief Emergency stop disabled value.
 *
 */
const octet PSYNC_EMERGENCY_STOP_DISABLED = 0x00;


/**
 * @brief Sonar detection range not available value.
 *
 */
const float PSYNC_SONAR_DETECTION_NOT_AVAILABLE = -1.0;


/**
 * @brief Sonar detection array index - front left side.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_FRONT_LEFT_SIDE = 0;


/**
 * @brief Sonar detection array index - front left corner.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_FRONT_LEFT_CORNER = 1;


/**
 * @brief Sonar detection array index - front left center.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_FRONT_LEFT_CENTER = 2;


/**
 * @brief Sonar detection array index - front right center.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_FRONT_RIGHT_CENTER = 3;


/**
 * @brief Sonar detection array index - front right corner.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_FRONT_RIGHT_CORNER = 4;


/**
 * @brief Sonar detection array index - front right side.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_FRONT_RIGHT_SIDE = 5;


/**
 * @brief Sonar detection array index - rear left side.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_REAR_LEFT_SIDE = 6;


/**
 * @brief Sonar detection array index - rear left corner.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_REAR_LEFT_CORNER = 7;


/**
 * @brief Sonar detection array index - rear left center.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_REAR_LEFT_CENTER = 8;


/**
 * @brief Sonar detection array index - rear right center.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_REAR_RIGHT_CENTER = 9;


/**
 * @brief Sonar detection array index - rear right corner.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_REAR_RIGHT_CORNER = 10;


/**
 * @brief Sonar detection array index - rear right side.
 *
 * Index in the array \ref ps_platform_surround_report_msg.sonar_detections .
 *
 */
const unsigned long PSYNC_SONAR_INDEX_REAR_RIGHT_SIDE = 11;




// *****************************************************
// enumerated types
// *****************************************************


/**
 * @brief Platform control mode kinds.
 *
 */
enum ps_platform_control_mode_kind
{
    //
    //
    PLATFORM_CONTROL_MODE_INVALID, /*!< Platform control mode information is invalid. */
    //
    //
    PLATFORM_CONTROL_MODE_UNKNOWN, /*!< Platform control mode information is unknown. */
    //
    //
    PLATFORM_CONTROL_MODE_NOT_AVAILABLE, /*!< Platform control mode information is not available. */
    //
    //
    PLATFORM_CONTROL_MODE_MANUAL, /*!< Platform control mode set to manual. */
    //
    //
    PLATFORM_CONTROL_MODE_AUTONOMOUS, /*!< Platform control mode set to autonomous. */
    //
    //
    PLATFORM_CONTROL_MODE_KIND_COUNT /*!< Number of \ref ps_platform_control_mode_kind values. */
};


/**
 * @brief Brake command kinds.
 *
 */
enum ps_brake_command_kind
{
    //
    //
    BRAKE_COMMAND_INVALID, /*!< Brake command information is invalid. */
    //
    //
    BRAKE_COMMAND_UNKNOWN, /*!< Brake command information is unknown. */
    //
    //
    BRAKE_COMMAND_NOT_AVAILABLE, /*!< Brake command information is not available. */
    //
    //
    BRAKE_COMMAND_PEDAL, /*!< Brake command set to use pedal percentage. */
    //
    //
    BRAKE_COMMAND_PERCENT, /*!< Brake command set to use percentage of maximum torque. */
    //
    //
    BRAKE_COMMAND_KIND_COUNT /*!< Number of \ref ps_brake_command_kind values. */
};


/**
 * @brief Throttle command kinds.
 *
 */
enum ps_throttle_command_kind
{
    //
    //
    THROTTLE_COMMAND_INVALID, /*!< Throttle command information is invalid. */
    //
    //
    THROTTLE_COMMAND_UNKNOWN, /*!< Throttle command information is unknown. */
    //
    //
    THROTTLE_COMMAND_NOT_AVAILABLE, /*!< Throttle command information is not available. */
    //
    //
    THROTTLE_COMMAND_PEDAL, /*!< Throttle command set to use pedal percentage. */
    //
    //
    THROTTLE_COMMAND_PERCENT, /*!< Brake command set to use percentage of maximum throttle. */
    //
    //
    THROTTLE_COMMAND_KIND_COUNT /*!< Number of \ref ps_throttle_command_kind values. */
};


/**
 * @brief Steering command kinds.
 *
 */
enum ps_steering_command_kind
{
    //
    //
    STEERING_COMMAND_INVALID, /*!< Steering command information is invalid. */
    //
    //
    STEERING_COMMAND_UNKNOWN, /*!< Steering command information is unknown. */
    //
    //
    STEERING_COMMAND_NOT_AVAILABLE, /*!< Steering command information is not available. */
    //
    //
    STEERING_COMMAND_ANGLE, /*!< Steering command set to use steering wheel angle. */
    //
    //
    STEERING_COMMAND_KIND_COUNT /*!< Number of \ref ps_steering_command_kind values. */
};


/**
 * @brief Gear position kinds.
 *
 */
enum ps_gear_position_kind
{
    //
    //
    GEAR_POSITION_INVALID, /*!< Gear position information is invalid. */
    //
    //
    GEAR_POSITION_UNKNOWN, /*!< Gear position information is unknown. */
    //
    //
    GEAR_POSITION_NOT_AVAILABLE, /*!< Gear position information is not available. */
    //
    //
    GEAR_POSITION_PARK, /*!< Gear position set to park. */
    //
    //
    GEAR_POSITION_REVERSE, /*!< Gear position set to reverse. */
    //
    //
    GEAR_POSITION_NEUTRAL, /*!< Gear position set to neutral. */
    //
    //
    GEAR_POSITION_DRIVE, /*!< Gear position set to drive. */
    //
    //
    GEAR_POSITION_LOW, /*!< Gear position set to low. */
    //
    //
    GEAR_POSITION_KIND_COUNT /*!< Number of \ref ps_gear_position_kind values. */
};


/**
 * @brief Platform turn signal kinds.
 *
 */
enum ps_platform_turn_signal_kind
{
    //
    //
    PLATFORM_TURN_SIGNAL_INVALID, /*!< Platform turn signal information is invalid. */
    //
    //
    PLATFORM_TURN_SIGNAL_UNKNOWN, /*!< Platform turn signal information is unknown. */
    //
    //
    PLATFORM_TURN_SIGNAL_NOT_AVAILABLE, /*!< Platform turn signal information is not available. */
    //
    //
    PLATFORM_TURN_SIGNAL_NONE, /*!< Platform turn signal set to none. */
    //
    //
    PLATFORM_TURN_SIGNAL_LEFT, /*!< Platform turn signal set to left. */
    //
    //
    PLATFORM_TURN_SIGNAL_RIGHT, /*!< Platform turn signal set to right. */
    //
    //
    PLATFORM_TURN_SIGNAL_KIND_COUNT /*!< Number of \ref ps_platform_turn_signal_kind values. */
};


/**
 * @brief Platform wiper state kinds.
 *
 */
enum ps_platform_wiper_state_kind
{
    //
    //
    PLATFORM_WIPER_STATE_INVALID, /*!< Platform wiper state information is invalid. */
    //
    //
    PLATFORM_WIPER_STATE_UNKNOWN, /*!< Platform wiper state information is unknown. */
    //
    //
    PLATFORM_WIPER_STATE_NOT_AVAILABLE, /*!< Platform wiper state information is not available. */
    //
    //
    PLATFORM_WIPER_STATE_OFF, /*!< Platform wiper state set to off. */
    //
    //
    PLATFORM_WIPER_STATE_MANUAL_ON, /*!< Platform wiper state set to manual on. */
    //
    //
    PLATFORM_WIPER_STATE_AUTO_ON, /*!< Platform wiper state set to auto on. */
    //
    //
    PLATFORM_WIPER_STATE_KIND_COUNT /*!< Number of \ref ps_platform_wiper_state_kind values. */
};


/**
 * @brief Platform ambient light state kinds.
 *
 */
enum ps_platform_ambient_light_kind
{
    //
    //
    PLATFORM_AMBIENT_LIGHT_INVALID, /*!< Platform ambient light information is invalid. */
    //
    //
    PLATFORM_AMBIENT_LIGHT_UNKNOWN, /*!< Platform ambient light information is unknown. */
    //
    //
    PLATFORM_AMBIENT_LIGHT_NOT_AVAILABLE, /*!< Platform ambient light information is not available. */
    //
    //
    PLATFORM_AMBIENT_LIGHT_DARK, /*!< Ambient lights are set to 'dark'. */
    //
    //
    PLATFORM_AMBIENT_LIGHT_LIGHT, /*!< Ambient lights are set to 'light'. */
    //
    //
    PLATFORM_AMBIENT_LIGHT_TWILIGHT, /*!< Ambient lights are set to 'twilight'. */
    //
    //
    PLATFORM_AMBIENT_LIGHT_TUNNEL_ON, /*!< Ambient lights are set to 'tunnel-on'. */
    //
    //
    PLATFORM_AMBIENT_LIGHT_TUNNEL_OFF, /*!< Ambient lights are set to 'tunnel-off'. */
    //
    //
    PLATFORM_AMBIENT_LIGHT_KIND_COUNT /*!< Number of \ref ps_platform_ambient_light_kind values. */
};


/**
 * @brief Platform hill start assist status kinds.
 *
 */
enum ps_platfrom_hill_start_assist_status_kind
{
    //
    //
    PLATFORM_HILL_START_ASSIST_STATUS_INVALID, /*!< Platform HSA status information is invalid. */
    //
    //
    PLATFORM_HILL_START_ASSIST_STATUS_UNKNOWN, /*!< Platform HSA status information is unknown. */
    //
    //
    PLATFORM_HILL_START_ASSIST_STATUS_NOT_AVAILABLE, /*!< Platform HSA status information is not available. */
    //
    //
    PLATFORM_HILL_START_ASSIST_STATUS_INACTIVE, /*!< HSA status 'inactive'. */
    //
    //
    PLATFORM_HILL_START_ASSIST_STATUS_FINDING_GRADIENT, /*!< HSA status 'finding-gradient'. */
    //
    //
    PLATFORM_HILL_START_ASSIST_STATUS_ACTIVE_PRESSED, /*!< HSA status 'active-pressed'. */
    //
    //
    PLATFORM_HILL_START_ASSIST_STATUS_ACTIVE_RELEASED, /*!< HSA status 'active-released'. */
    //
    //
    PLATFORM_HILL_START_ASSIST_STATUS_FAST_RELEASE, /*!< HSA status 'fast-release'. */
    //
    //
    PLATFORM_HILL_START_ASSIST_STATUS_SLOW_RELEASE, /*!< HSA status 'slow-release'. */
    //
    //
    PLATFORM_HILL_START_ASSIST_STATUS_FAILED, /*!< HSA status 'failed'. */
    //
    //
    PLATFORM_HILL_START_ASSIST_STATUS_KIND_COUNT /*!< Number of \ref ps_platfrom_hill_start_assist_status_kind values. */
};


/**
 * @brief Platform hill start assist mode kinds.
 *
 */
enum ps_platfrom_hill_start_assist_mode_kind
{
    //
    //
    PLATFORM_HILL_START_ASSIST_MODE_INVALID, /*!< Platform HSA mode information is invalid. */
    //
    //
    PLATFORM_HILL_START_ASSIST_MODE_UNKNOWN, /*!< Platform HSA mode information is unknown. */
    //
    //
    PLATFORM_HILL_START_ASSIST_MODE_NOT_AVAILABLE, /*!< Platform HSA mode information is not available. */
    //
    //
    PLATFORM_HILL_START_ASSIST_MODE_OFF, /*!< HSA mode 'off'. */
    //
    //
    PLATFORM_HILL_START_ASSIST_MODE_AUTO, /*!< HSA mode 'auto'. */
    //
    //
    PLATFORM_HILL_START_ASSIST_MODE_MANUAL, /*!< HSA mode 'manual'. */
    //
    //
    PLATFORM_HILL_START_ASSIST_MODE_KIND_COUNT /*!< Number of \ref ps_platfrom_hill_start_assist_mode_kind values. */
};


/**
 * @brief Platform parking brake status kinds.
 *
 */
enum ps_platfrom_parking_brake_status_kind
{
    //
    //
    PLATFORM_PARKING_BRAKE_STATUS_INVALID, /*!< Platform parking brake status information is invalid. */
    //
    //
    PLATFORM_PARKING_BRAKE_STATUS_UNKNOWN, /*!< Platform parking brake status information is unknown. */
    //
    //
    PLATFORM_PARKING_BRAKE_STATUS_NOT_AVAILABLE, /*!< Platform parking brake status information is not available. */
    //
    //
    PLATFORM_PARKING_BRAKE_STATUS_OFF, /*!< Parking brake status 'off'. */
    //
    //
    PLATFORM_PARKING_BRAKE_STATUS_TRANSITION, /*!< Parking brake status 'transitioning'. */
    //
    //
    PLATFORM_PARKING_BRAKE_STATUS_ON, /*!< Parking brake status 'on'. */
    //
    //
    PLATFORM_PARKING_BRAKE_STATUS_KIND_COUNT /*!< Number of \ref ps_platfrom_parking_brake_status_kind values. */
};




// *****************************************************
// data structures
// *****************************************************




// *****************************************************
// message types
// *****************************************************


/**
 * @brief Generic high-level platform control message.
 *
 * Arbitration key member(s): header.src_guid, dest_guid
 *
 */
struct ps_platform_control_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_guid dest_guid; /*!< Destination GUID.
                                            * Value \ref PSYNC_GUID_INVALID means not used. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the control command(s). [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    float speed; /*!< Desired speed.
                  * Value zero means stopped. [meters/second] */
    //
    //
    float acceleration_limit; /*!< Desired acceleration limit.
                               * Value zero means no limit. [meters/second^2] */
    //
    //
    float decceleration_limit; /*!< Desired decceleration limit.
                                * Value zero means no limit. [meters/second^2] */
    //
    //
    float curvature; /*!< Desired steering curvature.
                      * Value zero means straight ahead. [1/meters] */
    //
    //
    float max_curvature_rate; /*!< Desired maximum steering curvature rate. [1/meters/sec] */
};
///@cond INTERNAL
#pragma keylist ps_platform_control_msg header.src_guid, dest_guid
#pragma expose ps_platform_control_msg
///@endcond


/**
 * @brief Generic platform brake command message.
 *
 * Arbitration key member(s): header.src_guid, dest_guid
 *
 */
struct ps_platform_brake_command_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_guid dest_guid; /*!< Destination GUID.
                                            * Value \ref PSYNC_GUID_INVALID means not used. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the control command(s). [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    octet enabled; /*!< Desired brake enabled state.
                    * Value zero means disabled.
                    * Any other value means enabled. */
    //
    //
    octet boo_enabled; /*!< Desired brake on-off (brake lights) state.
                        * Value zero means disabled.
                        * Any other value means enabled. */
    //
    //
    ps_brake_command_kind brake_command_type; /*!< Brake command kind.
                                               * Indicates what type of brake command to apply.
                                               * Value \ref BRAKE_COMMAND_INVALID means no brake command applied. */
    //
    //
    float brake_command; /*!< Desired brake pedal command value.
                          * Specifies pedal percentage (normalized) when brake_command_type set to \ref BRAKE_COMMAND_PEDAL.
                          * Specifies percentage of maximum torque (normalized) when brake_command_type set to \ref BRAKE_COMMAND_PERCENT.
                          * Value zero means no brake applied. [normalized] */
};
///@cond INTERNAL
#pragma keylist ps_platform_brake_command_msg header.src_guid, dest_guid
#pragma expose ps_platform_brake_command_msg
///@endcond


/**
 * @brief Generic platform brake report message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_brake_report_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the report. [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    ps_platform_control_mode_kind control_mode; /*!< Brake control mode.
                                                 * Value \ref PLATFORM_CONTROL_MODE_MANUAL means brake controls are applied by the driver.
                                                 * Value \ref PLATFORM_CONTROL_MODE_AUTONOMOUS means brake controls are applied autonomously. */
    //
    //
    octet enabled; /*!< Brake enabled state.
                    * Value zero means disabled.
                    * Any other value means enabled. */
    //
    //
    float pedal_input; /*!< Brake pedal input value. [normalized] */
    //
    //
    float pedal_command; /*!< Brake pedal command value. [normalized] */
    //
    //
    float pedal_output; /*!< Brake pedal output value. [normalized] */
    //
    //
    float torque_input; /*!< Braking torque input value. [Newton meter] */
    //
    //
    float torque_command; /*!< Braking torque command value. [Newton meter] */
    //
    //
    float torque_output; /*!< Braking torque output value. [Newton meter] */
};
///@cond INTERNAL
#pragma keylist ps_platform_brake_report_msg header.src_guid
#pragma expose ps_platform_brake_report_msg
///@endcond


/**
 * @brief Generic platform throttle command message.
 *
 * Arbitration key member(s): header.src_guid, dest_guid
 *
 */
struct ps_platform_throttle_command_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_guid dest_guid; /*!< Destination GUID.
                                            * Value \ref PSYNC_GUID_INVALID means not used. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the control command(s). [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    octet enabled; /*!< Desired throttle enabled state.
                    * Value zero means disabled.
                    * Any other value means enabled. */
    //
    //
    ps_throttle_command_kind throttle_command_type; /*!< Throttle command kind.
                                                     * Indicates what type of throttle command to apply.
                                                     * Value \ref THROTTLE_COMMAND_INVALID means no brake command applied. */
    //
    //
    float throttle_command; /*!< Desired throttle pedal command value.
                             * Specifies pedal percentage (normalized) when throttle_command_type set to \ref THROTTLE_COMMAND_PEDAL.
                             * Specifies percentage of maximum throttle (normalized) when throttle_command_type set to \ref THROTTLE_COMMAND_PERCENT.
                             * Value zero means no throttle applied. [normalized] */
};
///@cond INTERNAL
#pragma keylist ps_platform_throttle_command_msg header.src_guid, dest_guid
#pragma expose ps_platform_throttle_command_msg
///@endcond


/**
 * @brief Generic platform throttle report message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_throttle_report_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the report. [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    ps_platform_control_mode_kind control_mode; /*!< Throttle control mode.
                                                 * Value \ref PLATFORM_CONTROL_MODE_MANUAL means throttle controls are applied by the driver.
                                                 * Value \ref PLATFORM_CONTROL_MODE_AUTONOMOUS means throttle controls are applied autonomously. */
    //
    //
    octet enabled; /*!< Throttle enabled state.
                    * Value zero means disabled.
                    * Any other value means enabled. */
    //
    //
    float pedal_input; /*!< Throttle pedal input value. [normalized] */
    //
    //
    float pedal_command; /*!< Throttle pedal command value. [normalized] */
    //
    //
    float pedal_output; /*!< Throttle pedal output value. [normalized] */
};
///@cond INTERNAL
#pragma keylist ps_platform_throttle_report_msg header.src_guid
#pragma expose ps_platform_throttle_report_msg
///@endcond


/**
 * @brief Generic platform steering command message.
 *
 * Arbitration key member(s): header.src_guid, dest_guid
 *
 */
struct ps_platform_steering_command_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_guid dest_guid; /*!< Destination GUID.
                                            * Value \ref PSYNC_GUID_INVALID means not used. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the control command(s). [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    octet enabled; /*!< Desired steering enabled state.
                    * Value zero means disabled.
                    * Any other value means enabled. */
    //
    //
    ps_steering_command_kind steering_command_kind; /*!< Steering command kind.
                                                     * Indicates what type of steering command to apply.
                                                     * Value \ref STEERING_COMMAND_INVALID means no steering command applied. */
    //
    //
    float steering_wheel_angle; /*!< Desired steering wheel angle.
                                 * Used when steering_command set to \ref STEERING_COMMAND_ANGLE.
                                 * Value zero means straight ahead. [radians] */
    //
    //
    float max_steering_wheel_rotation_rate; /*!< Desired maximum steering wheel rotation rate. [radians/second] */
};
///@cond INTERNAL
#pragma keylist ps_platform_steering_command_msg header.src_guid, dest_guid
#pragma expose ps_platform_steering_command_msg
///@endcond


/**
 * @brief Generic platform steering report message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_steering_report_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the report. [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    ps_platform_control_mode_kind control_mode; /*!< Steering control mode.
                                                 * Value \ref PLATFORM_CONTROL_MODE_MANUAL means steering controls are applied by the driver.
                                                 * Value \ref PLATFORM_CONTROL_MODE_AUTONOMOUS means steering controls are applied autonomously. */
    //
    //
    octet enabled; /*!< Steering enabled state.
                    * Value zero means disabled.
                    * Any other value means enabled. */
    //
    //
    float steering_wheel_angle; /*!< Steering wheel angle. [radians] */
    //
    //
    float steering_wheel_angle_command; /*!< Steering wheel command angle. [radians] */
    //
    //
    float steering_wheel_torque; /*!< Steering wheel torque. [Newton meters] */
};
///@cond INTERNAL
#pragma keylist ps_platform_steering_report_msg header.src_guid
#pragma expose ps_platform_steering_report_msg
///@endcond


/**
 * @brief Generic platform gear command message.
 *
 * Arbitration key member(s): header.src_guid, dest_guid
 *
 */
struct ps_platform_gear_command_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_guid dest_guid; /*!< Destination GUID.
                                            * Value \ref PSYNC_GUID_INVALID means not used. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the control command(s). [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    ps_gear_position_kind gear_position; /*!< Desired gear position.
                                          * Value \ref GEAR_POSITION_INVALID means no gear command applied. */
};
///@cond INTERNAL
#pragma keylist ps_platform_gear_command_msg header.src_guid, dest_guid
#pragma expose ps_platform_gear_command_msg
///@endcond


/**
 * @brief Generic platform gear report message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_gear_report_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the report. [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    ps_platform_control_mode_kind control_mode; /*!< Gear control mode.
                                                 * Value \ref PLATFORM_CONTROL_MODE_MANUAL means gear position controls are applied by the driver.
                                                 * Value \ref PLATFORM_CONTROL_MODE_AUTONOMOUS means gear position controls are applied autonomously. */
    //
    //
    ps_gear_position_kind position; /*!< Gear position. */
    //
    //
    ps_gear_position_kind position_command; /*!< Gear position command. */
};
///@cond INTERNAL
#pragma keylist ps_platform_gear_report_msg header.src_guid
#pragma expose ps_platform_gear_report_msg
///@endcond


/**
 * @brief Generic platform turn signal command message.
 *
 * Arbitration key member(s): header.src_guid, dest_guid
 *
 */
struct ps_platform_turn_signal_command_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_guid dest_guid; /*!< Destination GUID.
                                            * Value \ref PSYNC_GUID_INVALID means not used. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the control command(s). [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    ps_platform_turn_signal_kind turn_signal; /*!< Desired turn signal state.
                                               * Value \ref PLATFORM_TURN_SIGNAL_INVALID means no turn signal command applied. */
};
///@cond INTERNAL
#pragma keylist ps_platform_turn_signal_command_msg header.src_guid, dest_guid
#pragma expose ps_platform_turn_signal_command_msg
///@endcond


/**
 * @brief Generic platform cabin report message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_cabin_report_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the report. [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    ps_platform_turn_signal_kind turn_signal; /*!< Turn signal state. */
    //
    //
    octet high_beam_headlights; /*!< High beam headlight state.
                                 * Value zero means disabled.
                                 * Any other value means enabled. */
    //
    //
    ps_platform_wiper_state_kind wiper_state; /*!< Wiper state. */
};
///@cond INTERNAL
#pragma keylist ps_platform_cabin_report_msg header.src_guid
#pragma expose ps_platform_cabin_report_msg
///@endcond


/**
 * @brief Generic platform suspension report message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_suspension_report_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the report. [UTC microsecond] */
    //
    //
    float front_left; /*!< Front left suspension height. [meters] */
    //
    //
    float front_right; /*!< Front right suspension height. [meters] */
    //
    //
    float rear_left; /*!< Rear left suspension height. [meters] */
    //
    //
    float rear_right; /*!< Rear right suspension height. [meters] */
};
///@cond INTERNAL
#pragma keylist ps_platform_suspension_report_msg header.src_guid
#pragma expose ps_platform_suspension_report_msg
///@endcond


/**
 * @brief Generic platform tire pressure report message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_tire_pressure_report_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the report. [UTC microsecond] */
    //
    //
    float front_left; /*!< Front left tire pressure. [Pascals] */
    //
    //
    float front_right; /*!< Front right tire pressure. [Pascals] */
    //
    //
    float rear_left; /*!< Rear left tire pressure. [Pascals] */
    //
    //
    float rear_right; /*!< Rear right tire pressure. [Pascals] */
};
///@cond INTERNAL
#pragma keylist ps_platform_tire_pressure_report_msg header.src_guid
#pragma expose ps_platform_tire_pressure_report_msg
///@endcond


/**
 * @brief Generic platform wheel speed report message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_wheel_speed_report_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the report. [UTC microsecond] */
    //
    //
    float front_left; /*!< Front left wheel speed. [radians/second] */
    //
    //
    float front_right; /*!< Front right wheel speed. [radians/second] */
    //
    //
    float rear_left; /*!< Rear left wheel speed. [radians/second] */
    //
    //
    float rear_right; /*!< Rear right wheel speed. [radians/second] */
};
///@cond INTERNAL
#pragma keylist ps_platform_wheel_speed_report_msg header.src_guid
#pragma expose ps_platform_wheel_speed_report_msg
///@endcond


/**
 * @brief Generic platform extended cabin report message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_cabin_ext_report_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the report. [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    ps_platform_turn_signal_kind turn_signal; /*!< Turn signal state. */
    //
    //
    ps_platform_wiper_state_kind wiper_state; /*!< Wiper state. */
    //
    //
    octet high_beam_headlights; /*!< High beam headlight state.
                                 * Value zero means disabled.
                                 * Any other value means enabled. */
    //
    //
    ps_platform_ambient_light_kind ambient_lights; /*!< Ambient lights state. */
    //
    //
    float fuel_level; /*!< Fuel level. [normalized] */
    //
    //
    octet door_driver; /*!< Driver door open state.
                        * Value zero means closed.
                        * Value one means open. */
    //
    //
    octet door_passenger; /*!< Passenger door open state.
                           * Value zero means closed.
                           * Value one means open. */
    //
    //
    octet door_rear_left; /*!< Rear left door open state.
                           * Value zero means closed.
                           * Value one means open. */
    //
    //
    octet door_rear_right; /*!< Rear right door open state.
                            * Value zero means closed.
                            * Value one means open. */
    //
    //
    octet door_hood; /*!< Hood door open state.
                      * Value zero means closed.
                      * Value one means open. */
    //
    //
    octet door_trunk; /*!< Trunk door open state.
                       * Value zero means closed.
                       * Value one means open. */
    //
    //
    octet passenger_detect; /*!< Passenger detected state.
                             * Value zero means not detected.
                             * Value one means detected. */
    //
    //
    octet passenger_airbag; /*!< Passenger airbag enabled state.
                             * Value zero means disabled.
                             * Value one means enabled. */
    //
    //
    octet buckle_driver; /*!< Driver seat belt buckled state.
                          * Value zero means not buckled.
                          * Value one means buckled. */
    //
    //
    octet buckle_passenger; /*!< Passenger seat belt buckled state.
                             * Value zero means not buckled.
                             * Value one means buckled. */
    //
    //
    octet btn_cc_on; /*!< Cruise control on button state.
                      * Value zero means disabled.
                      * Value one means enabled. */
    //
    //
    octet btn_cc_off; /*!< Cruise control off button state.
                       * Value zero means disabled.
                       * Value one means enabled. */
    //
    //
    octet btn_cc_on_off; /*!< Cruise control on/off toggle button state.
                          * Value zero means disabled.
                          * Value one means enabled. */
    //
    //
    octet btn_cc_resume; /*!< Cruise control resume button state.
                          * Value zero means disabled.
                          * Value one means enabled. */
    //
    //
    octet btn_cc_cancel; /*!< Cruise control cancel button state.
                          * Value zero means disabled.
                          * Value one means enabled. */
    //
    //
    octet btn_cc_resume_cancel; /*!< Cruise control resume/cancel button state.
                                 * Value zero means disabled.
                                 * Value one means enabled. */
    //
    //
    octet btn_cc_set_increment; /*!< Cruise control set increment button state.
                                 * Value zero means disabled.
                                 * Value one means enabled. */
    //
    //
    octet btn_cc_set_decrement; /*!< Cruise control set decrement button state.
                                 * Value zero means disabled.
                                 * Value one means enabled. */
    //
    //
    octet btn_cc_gap_increment; /*!< Cruise control gap increment button state.
                                 * Value zero means disabled.
                                 * Value one means enabled. */
    //
    //
    octet btn_cc_gap_decrement; /*!< Cruise control gap decrement button state.
                                 * Value zero means disabled.
                                 * Value one means enabled. */
    //
    //
    octet btn_la_on_off; /*!< Lane assist on/off toggle button state.
                          * Value zero means disabled.
                          * Value one means enabled. */
};
///@cond INTERNAL
#pragma keylist ps_platform_cabin_ext_report_msg header.src_guid
#pragma expose ps_platform_cabin_ext_report_msg
///@endcond


/**
 * @brief Generic platform brake information message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_brake_information_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the report. [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    float brake_torque_request; /*!< Requested braking torque. [Newton meters] */
    //
    //
    float brake_torque_actual; /*!< Actual braking torque. [Newton meters] */
    //
    //
    float wheel_torque_actual; /*!< Actual wheel torque. [Newton meters] */
    //
    //
    float acceleration_over_ground; /*!< Platform acceleration over ground. [meters/second^2] */
    //
    //
    ps_platfrom_hill_start_assist_mode_kind hsa_mode; /*!< HSA mode. */
    //
    //
    ps_platfrom_hill_start_assist_status_kind hsa_status; /*!< HSA status. */
    //
    //
    ps_platfrom_parking_brake_status_kind parking_brake_status; /*!< Parking brake status. */
    //
    //
    octet stationary; /*!< Platform stationary state.
                       * Value zero means not stationary.
                       * Value one means stationary. */
    //
    //
    octet abs_active; /*!< Anti-lock brake system active state.
                          * Value zero means not active.
                          * Value one means active. */
    //
    //
    octet abs_enabled; /*!< Anti-lock brake system enabled state.
                          * Value zero means disable.
                          * Value one means enabled. */
    //
    //
    octet stab_active; /*!< Stability control active state.
                        * Value zero means not active.
                        * Value one means active. */
    //
    //
    octet stab_enabled; /*!< Stability control enabled state.
                         * Value zero means disable.
                         * Value one means enabled. */
    //
    //
    octet trac_active; /*!< Traction control active state.
                        * Value zero means not active.
                        * Value one means active. */
    //
    //
    octet trac_enabled; /*!< Traction control enabled state.
                         * Value zero means disable.
                         * Value one means enabled. */
};
///@cond INTERNAL
#pragma keylist ps_platform_brake_information_msg header.src_guid
#pragma expose ps_platform_brake_information_msg
///@endcond


/**
 * @brief Generic platform surround report message.
 *
 * Arbitration key member(s): header.src_guid
 *
 */
struct ps_platform_surround_report_msg
{
    //
    //
    ps_msg_header header; /*!< PolySync message header. */
    //
    //
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    //
    //
    ps_timestamp timestamp; /*!< Timestamp associated with the report. [UTC microsecond] */
    //
    //
    octet e_stop; /*!< Emergency stop state.
                   * Value \ref PSYNC_EMERGENCY_STOP_DISABLED means disabled.
                   * Any other value means enabled. */
    //
    //
    octet cta_left_alert; /*!< Left cross traffic alert state.
                           * Value zero means not active.
                           * Value one means active. */
    //
    //
    octet cta_left_enabled; /*!< Left cross traffic alert enabled state.
                             * Value zero means disable.
                             * Value one means enabled. */
    //
    //
    octet cta_right_alert; /*!< Right cross traffic alert state.
                            * Value zero means not active.
                            * Value one means active. */
    //
    //
    octet cta_right_enabled; /*!< Right cross traffic alert enabled state.
                              * Value zero means disable.
                              * Value one means enabled. */
    //
    //
    octet blis_left_alert; /*!< Left blind spot information system alert state.
                            * Value zero means not active.
                            * Value one means active. */
    //
    //
    octet blis_left_enabled; /*!< Left blind spot information system enabled state.
                              * Value zero means disable.
                              * Value one means enabled. */
    //
    //
    octet blis_right_alert; /*!< Right blind spot information system alert state.
                             * Value zero means not active.
                             * Value one means active. */
    //
    //
    octet blis_right_enabled; /*!< Right blind spot information system enabled state.
                               * Value zero means disable.
                               * Value one means enabled. */
    //
    //
    octet sonar_enabled; /*!< Sonar sensors enabled state.
                          * Value zero means disable.
                          * Value one means enabled. */
    //
    //
    float sonar_detections[12]; /*!< Platform sonar sensor detections. [meters]
                                 * Value \ref PSYNC_SONAR_DETECTION_NOT_AVAILABLE means not available.
                                 * Value zero means no detection.
                                 * See \ref PSYNC_SONAR_INDEX_FRONT_LEFT_SIDE for indices. */
};
///@cond INTERNAL
#pragma keylist ps_platform_surround_report_msg header.src_guid
#pragma expose ps_platform_surround_report_msg
///@endcond
/**
 * @file swiftnav.idl
 * @brief Swift Navigation Data Model.
 *
 * The prefix 'sbp' (Swift Navigation Binary Protocol) is used to identify data types from this module.
 *
 * Message definitions use the naming convention 'sbp_msg_<package>_<name>'.
 *
 */


/**
 * @brief Swift Navigation data model major version.
 *
 * Indicates a major release version.
 *
 */
const octet SWIFTNAV_MODULE_VERSION_MAJOR = 1;


/**
 * @brief Swift Navigation data model minor version.
 *
 * Indicates a minor release version.
 * Increased each time the syntax of the module
 * is changed (ie new or removed messages, new or removed message fields, changed number of bits, etc).
 *
 */
const octet SWIFTNAV_MODULE_VERSION_MINOR = 1;


/**
 * @brief Swift Navigation data model sub-minor version.
 *
 * Indicates a sub-minor release version.
 * Increased each time the semantics of the
 * data model are modified (ie interpretation of field values or similar).
 *
 */
const unsigned short SWIFTNAV_MODULE_VERSION_SUBMINOR = 0;


// *****************************************************
// constants
// *****************************************************


/**
 * @brief SBP protocol identifier.
 *
 */
const octet SBP_LOGGING_FORWARD_PROTOCOL_SBP = 0;


/**
 * @brief Maximum number of bytes in a settings string.
 *
 */
const octet SBP_SETTINGS_STRING_MAX_SIZE = 255;


/**
 * @brief Maximum number of observations in an observations message array.
 *
 */
const octet SBP_OBSERVATIONS_MAX_LENGTH = 255;


/**
 * @brief Sender ID of the host used to send messages to the device.
 *
 */
const unsigned short SBP_MSG_SENDER_ID_CLIENT = 0x0042;


// *****************************************************
// enumerated types
// *****************************************************


/**
 * @brief Logging levels.
 *
 */
enum sbp_log_level_kind
{
    SBP_LOG_LEVEL_EMERGENCY, /*!< Emergency. */
    SBP_LOG_LEVEL_ALERT, /*!< Alert. */
    SBP_LOG_LEVEL_CRITICAL, /*!< Critical. */
    SBP_LOG_LEVEL_ERROR, /*!< Error. */
    SBP_LOG_LEVEL_WARNING, /*!< Warning. */
    SBP_LOG_LEVEL_NOTICE, /*!< Notice. */
    SBP_LOG_LEVEL_INFO, /*!< Informative. */
    SBP_LOG_LEVEL_DEBUG, /*!< Debugging. */
    SBP_LOG_LEVEL_KIND_COUNT /*!< Number of \ref sbp_log_level_kind values. */
};


/**
 * @brief Time sources.
 *
 */
enum sbp_time_source_kind
{
    SBP_TIME_SOURCE_NONE, /*!< None (invalid). */
    SBP_TIME_SOURCE_GNSS, /*!< GNSS solution. */
    SBP_TIME_SOURCE_KIND_COUNT /*!< Number of \ref sbp_time_source_kind values. */
};


/**
 * @brief Time offset sources.
 *
 */
enum sbp_utc_offset_source_kind
{
    SBP_UTC_OFFSET_SOURCE_FACTORY_DEFAULT, /*!< Factory default. */
    SBP_UTC_OFFSET_SOURCE_NONVOLATILE_MEMORY, /*!< Non-volatile memory. */
    SBP_UTC_OFFSET_SOURCE_SESSION, /*!< Decoded this session. */
    SBP_UTC_OFFSET_SOURCE_KIND_COUNT /*!< Number of \ref sbp_utc_offset_source_kind values. */
};


/**
 * @brief Fix modes.
 *
 */
enum sbp_fix_mode_kind
{
    SBP_FIX_MODE_INVALID, /*!< Invalid. */
    SBP_FIX_MODE_SPP, /*!< Single point precision. */
    SBP_FIX_MODE_DGNSS, /*!< Differential GNSS. */
    SBP_FIX_MODE_FLOAT_RTK, /*!< Float RTK. */
    SBP_FIX_MODE_FIXED_RTK, /*!< Fixed RTK. */
    SBP_FIX_MODE_KIND_COUNT /*!< Number of \ref sbp_fix_mode_kind values. */
};


/**
 * @brief Velocity modes.
 *
 */
enum sbp_velocity_mode_kind
{
    SBP_VELOCITY_MODE_INVALID, /*!< Invalid. */
    SBP_VELOCITY_MODE_MDD, /*!< Measured Doppler derived. */
    SBP_VELOCITY_MODE_CDD, /*!< Computed Doppler derived. */
    SBP_VELOCITY_MODE_KIND_COUNT /*!< Number of \ref sbp_velocity_mode_kind values. */
};


/**
 * @brief Signal codes.
 *
 */
enum sbp_signal_code_kind
{
    SBP_SIGNAL_CODE_GPS_L1CA, /*!< GPS L1CA. */
    SBP_SIGNAL_CODE_GPS_L2CM, /*!< GPS L2CM. */
    SBP_SIGNAL_CODE_SBAS_L1CA, /*!< SBAS L1CA. */
    SBP_SIGNAL_CODE_GLO_L1CA, /*!< GLO L1CA. */
    SBP_SIGNAL_CODE_GLO_L2CA, /*!< GLO L2CA. */
    SBP_SIGNAL_CODE_GPS_L1P, /*!< GPS L1P. */
    SBP_SIGNAL_CODE_GPS_L2P, /*!< GPS L2P. */
    SBP_SIGNAL_CODE_KIND_COUNT /*!< Number of \ref sbp_signal_code_kind values. */
};


/**
 * @brief Startup causes.
 *
 */
enum sbp_startup_cause_kind
{
    SBP_STARTUP_CAUSE_POWER_ON, /*!< Power on. */
    SBP_STARTUP_CAUSE_SOFTWARE_RESET, /*!< Software reset. */
    SBP_STARTUP_CAUSE_WATCHDOG_RESET, /*!< Watchdog reset. */
    SBP_STARTUP_CAUSE_KIND_COUNT /*!< Number of \ref sbp_startup_cause_kind values. */
};


/**
 * @brief Startup types.
 *
 */
enum sbp_startup_type_kind
{
    SBP_STARTUP_TYPE_COLD_START, /*!< Cold start. */
    SBP_STARTUP_TYPE_WARM_START, /*!< Warn start. */
    SBP_STARTUP_TYPE_HOT_START, /*!< Hot start. */
    SBP_STARTUP_TYPE_KIND_COUNT /*!< Number of \ref sbp_startup_type_kind values. */
};


/**
 * @brief Differential types.
 *
 */
enum sbp_differential_type_kind
{
    SBP_DIFFERENTIAL_TYPE_INVALID, /*!< Invalid. */
    SBP_DIFFERENTIAL_TYPE_CODE_DIFFERENCE, /*!< Code difference. */
    SBP_DIFFERENTIAL_TYPE_RTK, /*!< RTK. */
    SBP_DIFFERENTIAL_TYPE_KIND_COUNT /*!< Number of \ref sbp_differential_type_kind values. */
};


// *****************************************************
// data structures
// *****************************************************


/**
 * @brief Nanosecond-accurate GPS time.
 *
 * Defined as the time
 * since the beginning of the week on the Saturday/Sunday transition.
 *
 */
struct sbp_gps_time
{
    unsigned short week; /*!< GPS week number. */
    unsigned long time_of_week; /*!< GPS time of week rounded to the nearest millisecond. [milliseconds] */
    long residual; /*!< Nanosecond residual of millisecond-rounded time-of-week (ranges -500,000 to 500,000). [nanoseconds] */
    sbp_time_source_kind time_source; /*!< Time source. */
};

/**
 * @brief Nanosecond-accurate UTC time.
 *
 */
struct sbp_utc_time
{
    unsigned long time_of_week; /*!< GPS time of week rounded to the nearest millisecond. [milliseconds] */
    unsigned short year; /*!< Year. */
    octet month; /*!< Month (range 1 to 12). */
    octet day; /*!< Days in the month (range 1 to 31). */
    octet hours; /*!< Hours of the day (range 0 to 23). */
    octet minutes; /*!< Minutes of the hour (range 0 to 59). */
    octet seconds; /*!< Seconds of the minute (range 0 to 60). */
    long nanoseconds; /*!< Nanosecond residual of millisecond-rounded time-of-week (ranges -500,000 to 500,000). [nanoseconds] */
    sbp_time_source_kind time_source; /*!< Time source. */
    sbp_utc_offset_source_kind offset_source; /*!< Time offset source. */
};


/**
 * @brief GNSS Doppler measurement.
 *
 * Doppler measurement in Hz represented as a 24-bit
 * fixed point number with Q16.8 layout, i.e. 16-bits of whole
 * Doppler and 8-bits of fractional Doppler. This Doppler is defined
 * as positive for approaching satellites.
 *
 */
struct sbp_doppler
{
    short integer; /*!< Doppler whole Hz. [Hertz] */
    octet fraction; /*!< Doppler fractional part. [Hertz / 256] */
};


/**
 * @brief GNSS carrier phase measurement.
 *
 * Carrier phase measurement in cycles represented as a 40-bit
 * fixed point number with Q32.8 layout, i.e. 32-bits of whole
 * cycles and 8-bits of fractional cycles. This phase has the
 * same sign as the pseudorange.
 *
 */
struct sbp_carrier_phase
{
    long integer; /*!< Carrier phase whole cycles. [cycles] */
    octet fraction; /*!< Carrier phase fractional part. [cycles / 256] */
};


/**
 * @brief Represents all the relevant information about the signal.
 *
 * Signal identifier containing constellation, band, and satellite identifier.
 *
 */
struct sbp_gnss_signal16
{
    octet id; /*!< Constellation-specific satellite identifier. */
    sbp_signal_code_kind code; /*!< Signal constellation, band and code. */
};


/**
 * @brief Represents all the relevant information about the signal.
 *
 * Signal identifier containing constellation, band, and satellite identifier.
 *
 * @note Unlike \ref sbp_gnss_signal16, GPS satellites are encoded as (PRN - 1).
 * Other constellations do not have this offset.
 *
 */
struct sbp_gnss_signal
{
    unsigned short id; /*!< Constellation-specific satellite identifier. */
    sbp_signal_code_kind code; /*!< Signal constellation, band and code. */
};


/**
 * @brief Observation header.
 *
 */
struct sbp_observation_header
{
    sbp_gps_time time; /*!< GNSS time of this observation. */
    octet length; /*!< Total number of observations, this is also the length of the observation sequence (n). */
    octet index; /*!< Zero-indexed counter (ith packet of n). */
};


/**
 * @brief Observation header.
 *
 */
struct sbp_satellite_observation
{
    unsigned long pseudorange; /*!< Pseudorange observation. [2 cm] */
    sbp_carrier_phase carrier_phase; /*!< Carrier phase observation with typical sign convention. [cycles] */
    sbp_doppler doppler; /*!< Doppler observation with typical sign convention. [Hertz] */
    octet carrier_noise_density; /*!< Carrier-to-Noise density. Zero implies invalid. [dB Hertz / 4] */
    octet lock; /*!< Lock timer. This value gives an indication of the time
                 * for which a signal has maintained continuous phase lock.
                 * Whenever a signal has lost and regained lock, this
                 * value is reset to zero. It is encoded according to DF402 from
                 * the RTCM 10403.2 Amendment 2 specification.  Valid values range
                 * from 0 to 15 and the most significant nibble is reserved for future use. */
    sbp_gnss_signal16 signal_id; /*!< GNSS signal identifier. */
    octet pseudorange_valid; /*!< Pseudorange valid. */
    octet carrier_phase_valid; /*!< Carrier phase valid. */
    octet half_cycle_phase_ambiguity_resolved; /*!< Half-cycle ambiguity resolved state. */
    octet doppler_valid; /*!< Doppler valid. */
};


// *****************************************************
// message types
// *****************************************************


/**
 * \defgroup swiftnav_group_msg_system System Messages
 *
 * * Standardized system messages from Swift Navigation devices.
 * \{ */


/**
 * @brief System start-up message.
 *
 * The system start-up message is sent once on system
 * start-up. It notifies the host or other attached devices that
 * the system has started and is now ready to respond to commands
 * or configuration requests.
 *
 */
struct sbp_msg_system_startup
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_startup_cause_kind cause; /*!< Cause of startup. */
    sbp_startup_type_kind type; /*!< Startup type. */
};

#pragma keylist sbp_msg_system_startup header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_system_startup


/**
 * @brief System heartbeat message.
 *
 * The heartbeat message is sent periodically to inform the host
 * or other attached devices that the system is running. It is
 * used to monitor system malfunctions. It also contains status
 * flags that indicate to the host the status of the system and
 * whether it is operating correctly. Currently, the expected
 * heartbeat interval is 1 second.
 *
 * The system error flag is used to indicate that an error has
 * occurred in the system.
 *
 */
struct sbp_msg_system_heartbeat
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    octet protocol_version_minor; /*!< SBP minor protocol version number. */
    octet protocol_version_major; /*!< SBP major protocol version number. */
    octet system_error; /*!< System error status. */
    octet io_error; /*!< I/O error status. */
    octet swiftnap_error; /*!< SwiftNAP error status. */
    octet external_antenna_present; /*!< External antenna present. */
};

#pragma keylist sbp_msg_system_heartbeat header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_system_heartbeat


/**
 * @brief Status of received corrections.
 *
 * This message provides information about the receipt of Differential
 * corrections.  It is expected to be sent with each receipt of a complete
 * corrections packet.
 *
 */
struct sbp_msg_system_dgnss_status
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_differential_type_kind differential_type; /*!< TODO. */
    unsigned short latency; /*!< Latency of observation receipt. [deci-seconds] */
    octet signal_count; /*!< Number of signals from base station. */
    sequence<char> source; /*!< Corrections source string. */
};

#pragma keylist sbp_msg_system_dgnss_status header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_system_dgnss_status

/** \} */


/** \defgroup swiftnav_group_msg_logging Logging Messages
 *
 *  * Logging and debugging messages from the device.
 * \{ */


/**
 * @brief Plaintext logging messages with levels.
 *
 * This message contains a human-readable payload string from the
 * device containing errors, warnings and informational messages
 * with logging levels.
 *
 */
struct sbp_msg_logging_log
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_log_level_kind level; /*!< Logging level. */
    sequence<char> text; /*!< Human-readable string. */
};

#pragma keylist sbp_msg_logging_log header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_logging_log


/**
 * @brief Wrapper message for FWD a separate stream of information over SBP.
 *
 * This message provides the ability to forward messages over SBP.
 * This may take the form
 * of wrapping up SBP messages received by Piksi for logging purposes or wrapping
 * another protocol with SBP.
 *
 * The source identifier indicates from what interface a forwarded stream derived.
 * The protocol identifier identifies what the expected protocol
 * the forwarded message contains.
 * Protocol \ref SBP_LOGGING_FORWARD_PROTOCOL_SBP represents SBP
 * and the remaining values are implementation defined.
 *
 */
struct sbp_msg_logging_forward
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    octet source; /*!< Source identifier. */
    octet protocol; /*!< Protocol identifier. */
    sequence<octet> payload; /*!< Binary message. */
};

#pragma keylist sbp_msg_logging_forward header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_logging_forward

/** \} */


/** \defgroup swiftnav_group_msg_navigation Navigation Messages
 *
 * Geodetic navigation messages reporting GPS time, position, velocity,
 * and baseline position solutions. For position solutions, these
 * messages define several different position solutions: single-point
 * (SPP), RTK, and pseudo-absolute position solutions.
 *
 * The SPP is the standalone, absolute GPS position solution using only
 * a single receiver. The RTK solution is the differential GPS
 * solution, which can use either a fixed/integer or floating carrier
 * phase ambiguity. The pseudo-absolute position solution uses a
 * user-provided, well-surveyed base station position (if available)
 * and the RTK solution in tandem.
 * \{ */


/**
 * @brief GPS time message.
 *
 * This message reports the GPS time, representing the time since
 * the GPS epoch began on midnight January 6, 1980 UTC. GPS time
 * counts the weeks and seconds of the week. The weeks begin at the
 * Saturday/Sunday transition. GPS week 0 began at the beginning of
 * the GPS time scale.
 *
 * Within each week number, the GPS time of the week is between
 * between 0 and 604800 seconds (=60*60*24*7). Note that GPS time
 * does not accumulate leap seconds, and as of now, has a small
 * offset from UTC. In a message stream, this message precedes a
 * set of other navigation messages referenced to the same time
 * (but lacking the ns field) and indicates a more precise time of
 * these messages.
 *
 */
struct sbp_msg_navigation_gps_time
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_gps_time time; /*!< GPS time. */
};

#pragma keylist sbp_msg_navigation_gps_time header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_navigation_gps_time


/**
 * @brief UTC time message.
 *
 * This message reports the Universal Coordinated Time (UTC).
 *
 */
struct sbp_msg_navigation_utc_time
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_utc_time time; /*!< UTC time. */
};

#pragma keylist sbp_msg_navigation_utc_time header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_navigation_utc_time


/**
 * @brief Dilution of Precision.
 *
 * This dilution of precision (DOP) message describes the effect of
 * navigation satellite geometry on positional measurement
 * precision.  The flags field indicated whether the DOP reported
 * corresponds to differential or SPP solution.
 *
 */
struct sbp_msg_navigation_dops
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    unsigned short gdop; /*!< Geometric Dilution of Precision. [0.01] */
    unsigned short pdop; /*!< Position Dilution of Precision. [0.01] */
    unsigned short tdop; /*!< Time Dilution of Precision. [0.01] */
    unsigned short hdop; /*!< Horizontal Dilution of Precision. [0.01] */
    unsigned short vdop; /*!< Vertical Dilution of Precision. [0.01] */
    sbp_fix_mode_kind fix_mode; /*!< Fix mode. */
    octet raim_repair; /*!< Solution came from RAIM repair. */
};

#pragma keylist sbp_msg_navigation_dops header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_navigation_dops


/**
 * @brief Single-point position in ECEF.
 *
 * The position solution message reports absolute Earth Centered
 * Earth Fixed (ECEF) coordinates and the status (single point vs
 * pseudo-absolute RTK) of the position solution. If the rover
 * receiver knows the surveyed position of the base station and has
 * an RTK solution, this reports a pseudo-absolute position
 * solution using the base station position and the rover's RTK
 * baseline vector. The full GPS time is given by the preceding
 * \ref sbp_msg_navigation_gps_time with the matching time-of-week (tow).
 *
 */
struct sbp_msg_navigation_position_ecef
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    double x; /*!< ECEF X coordinate. [meters] */
    double y; /*!<  ECEF Y coordinate. [meters] */
    double z; /*!< ECEF Z coordinate. [meters] */
    unsigned short accuracy; /*!< Position accuracy estimate. [millimeters] */
    octet satellites; /*!< Number of satellites used in solution. */
    sbp_fix_mode_kind fix_mode; /*!< Fix mode. */
    octet raim_repair; /*!< Solution came from RAIM repair. */
};

#pragma keylist sbp_msg_navigation_position_ecef header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_navigation_position_ecef


/**
 * @brief Geodetic position.
 *
 * This position solution message reports the absolute geodetic
 * coordinates and the status (single point vs pseudo-absolute RTK)
 * of the position solution. If the rover receiver knows the
 * surveyed position of the base station and has an RTK solution,
 * this reports a pseudo-absolute position solution using the base
 * station position and the rover's RTK baseline vector. The full
 * GPS time is given by the preceding \ref sbp_msg_navigation_gps_time with the
 * matching time-of-week (tow).
 *
 */
struct sbp_msg_navigation_position_llh
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    double latitude; /*!< Latitude. [degrees] */
    double longitude; /*!< Longitude. [degrees] */
    double height; /*!< Height above WGS84 ellipsoid. [meters] */
    unsigned short horizontal_accuracy; /*!< Horizontal position accuracy estimate. [millimeters] */
    unsigned short vertical_accuracy; /*!< Vertical position accuracy estimate. [millimeters] */
    octet satellites; /*!< Number of satellites used in solution. */
    sbp_fix_mode_kind fix_mode; /*!< Fix mode. */
    octet raim_repair; /*!< Solution came from RAIM repair. */
};

#pragma keylist sbp_msg_navigation_position_llh header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_navigation_position_llh


/**
 * @brief Baseline position in ECEF.
 *
 * This message reports the baseline solution in Earth Centered
 * Earth Fixed (ECEF) coordinates. This baseline is the relative
 * vector distance from the base station to the rover receiver. The
 * full GPS time is given by the preceding \ref sbp_msg_navigation_gps_time with the
 * matching time-of-week (tow).
 *
 */
struct sbp_msg_navigation_baseline_ecef
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    long x; /*!< Baseline ECEF X coordinate. [millimeters] */
    long y; /*!< Baseline ECEF Y coordinate. [millimeters] */
    long z; /*!< Baseline ECEF Z coordinate. [millimeters] */
    unsigned short accuracy; /*!< Position accuracy estimate. [millimeters] */
    octet satellites; /*!< Number of satellites used in solution. */
    sbp_fix_mode_kind fix_mode; /*!< Fix mode. */
    octet raim_repair; /*!< Solution came from RAIM repair. */
};

#pragma keylist sbp_msg_navigation_baseline_ecef header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_navigation_baseline_ecef


/**
 * @brief Baseline position in NED.
 *
 * This message reports the baseline solution in North East Down
 * (NED) coordinates. This baseline is the relative vector distance
 * from the base station to the rover receiver, and NED coordinate
 * system is defined at the local WGS84 tangent plane centered at the
 * base station position.  The full GPS time is given by the
 * preceding \ref sbp_msg_navigation_gps_time with the matching time-of-week (tow).
 *
 */
struct sbp_msg_navigation_baseline_ned
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    long north; /*!< Baseline North coordinate. [millimeters] */
    long east; /*!< Baseline East coordinate. [millimeters] */
    long down; /*!< Baseline Down coordinate. [millimeters] */
    unsigned short horizontal_accuracy; /*!< Horizontal position accuracy estimate. [millimeters] */
    unsigned short vertical_accuracy; /*!< Vertical position accuracy estimate. [millimeters] */
    octet satellites; /*!< Number of satellites used in solution. */
    sbp_fix_mode_kind fix_mode; /*!< Fix mode. */
    octet raim_repair; /*!< Solution came from RAIM repair. */
};

#pragma keylist sbp_msg_navigation_baseline_ned header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_navigation_baseline_ned


/**
 * @brief Velocity in ECEF.
 *
 * This message reports the velocity in Earth Centered Earth Fixed
 * (ECEF) coordinates. The full GPS time is given by the preceding
 * \ref sbp_msg_navigation_gps_time with the matching time-of-week (tow).
 *
 */
struct sbp_msg_navigation_velocity_ecef
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    long x; /*!< Velocity ECEF X coordinate. [millimeters/second] */
    long y; /*!< Velocity ECEF Y coordinate. [millimeters/second] */
    long z; /*!< Velocity ECEF Z coordinate. [millimeters/second] */
    unsigned short accuracy; /*!< Velocity accuracy estimate (not implemented).
                              * Defaults to 0. [millimeters/second] */
    octet satellites; /*!< Number of satellites used in solution. */
    sbp_velocity_mode_kind velocity_mode; /*!< Velocity mode. */
};

#pragma keylist sbp_msg_navigation_velocity_ecef header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_navigation_velocity_ecef


/**
 * @brief Velocity in NED.
 *
 * This message reports the velocity in local North East Down (NED)
 * coordinates. The NED coordinate system is defined as the local WGS84
 * tangent plane centered at the current position. The full GPS time is
 * given by the preceding \ref sbp_msg_navigation_gps_time with the matching time-of-week (tow).
 *
 */
struct sbp_msg_navigation_velocity_ned
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    unsigned long north; /*!< Velocity North coordinate. [millimeters/second] */
    unsigned long east; /*!< Velocity East coordinate. [millimeters/second] */
    unsigned long down; /*!< Velocity Down coordinate. [millimeters/second] */
    unsigned short horizontal_accuracy; /*!< Horizontal velocity accuracy estimate (not implemented).
                                         * Defaults to 0. [millimeters/second] */
    unsigned short vertical_accuracy; /*!< Vertical velocity accuracy estimate (not implemented).
                                       * Defaults to 0. [millimeters/second] */
    octet satellites; /*!< Number of satellites used in solution. */
    sbp_velocity_mode_kind velocity_mode; /*!< Velocity mode. */
};

#pragma keylist sbp_msg_navigation_velocity_ned header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_navigation_velocity_ned


/**
 * @brief Heading relative to True North.
 *
 * This message reports the baseline heading pointing from the base station
 * to the rover relative to True North. The full GPS time is given by the
 * preceding \ref sbp_msg_navigation_gps_time with the matching time-of-week (tow). It is intended
 * that time-matched RTK mode is used when the base station is moving.
 *
 */
struct sbp_msg_navigation_baseline_heading
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    unsigned long heading; /*!< Heading. [millidegrees] */
    octet satellites; /*!< Number of satellites used in solution. */
    sbp_fix_mode_kind fix_mode; /*!< Fix mode. */
    octet raim_repair; /*!< Solution came from RAIM repair. */
};

#pragma keylist sbp_msg_navigation_baseline_heading header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_navigation_baseline_heading


/**
 * @brief Age of corrections.
 *
 * This message reports the Age of the corrections used for the current
 * Differential solution.
 *
 */
struct sbp_msg_navigation_age_corrections
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    unsigned short age; /*!< Age of the corrections (0xFFFF indicates invalid). [deciseconds] */
};

#pragma keylist sbp_msg_navigation_age_corrections header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_navigation_age_corrections

/** \} */


/** \defgroup swiftnav_group_msg_observation Observation Messages
 *
 * Satellite observation messages from the device.
 * \{ */


/**
 * @brief GPS satellite observations.
 *
 * The GPS observations message reports all the raw pseudorange and
 * carrier phase observations for the satellites being tracked by
 * the device.
 *
 */
struct sbp_msg_observation_observations
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_observation_header observation_header; /*!< Observation header. */
    sequence<sbp_satellite_observation> observations; /*!< Pseudorange and
                                                       * carrier phase observation for a
                                                       * satellite being tracked. */
};

#pragma keylist sbp_msg_observation_observations header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_observation_observations


/**
 * @brief Base station position.
 *
 * The base station position message is the position reported by
 * the base station itself. It is used for pseudo-absolute RTK
 * positioning, and is required to be a high-accuracy surveyed
 * location of the base station. Any error here will result in an
 * error in the pseudo-absolute position output.
 *
 */
struct sbp_msg_observation_base_position_llh
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double latitude; /*!< Latitude. [degrees] */
    double longitude; /*!< Longitude. [degrees] */
    double height; /*!< Height. [degrees] */
};

#pragma keylist sbp_msg_observation_base_position_llh header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_observation_base_position_llh


/**
 * @brief Base station position in ECEF.
 *
 * The base station position message is the position reported by
 * the base station itself in absolute Earth Centered Earth Fixed
 * coordinates. It is used for pseudo-absolute RTK positioning, and
 * is required to be a high-accuracy surveyed location of the base
 * station. Any error here will result in an error in the
 * pseudo-absolute position output.
 *
 */
struct sbp_msg_observation_base_position_ecef
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double x; /*!< ECEF X coodinate. [meters] */
    double y; /*!< ECEF Y coodinate. [meters] */
    double z; /*!< ECEF Z coodinate. [meters] */
};

#pragma keylist sbp_msg_observation_base_position_ecef header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_observation_base_position_ecef


/**
 * @brief Satellite broadcast ephemeris for GPS.
 *
 * The ephemeris message returns a set of satellite orbit
 * parameters that is used to calculate GPS satellite position,
 * velocity, and clock offset. Please see the Navstar GPS
 * Space Segment/Navigation user interfaces (ICD-GPS-200, Table
 * 20-III) for more details.
 *
 */
struct sbp_msg_observation_ephemeris_gps
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_gnss_signal signal_id; /*!< GNSS signal identifier */
    sbp_gps_time time_of_ephemerides; /*!< Time of Ephemerides */
    double user_range_accuracy; /*!< User Range Accuracy [meters] */
    unsigned long curve_fit_interval; /*!< Curve fit interval [seconds] */
    octet ephemeris_valid; /*!< Status of ephemeris, 1 = valid, 0 = invalid */
    octet health_bits; /*!< Satellite health status.
                        * GPS: ICD-GPS-200, chapter 20.3.3.3.1.4
                        * SBAS: 0 = valid, non-zero = invalid
                        * GLO: 0 = valid, non-zero = invalid */
    double group_delay_differential; /*!< Group delay differential between L1 and L2 [seconds] */
    double radius_correction_amplitude_sine; /*!< Amplitude of the sine harmonic
                                              * correction term to the orbit radius [meters] */
    double radius_correction_amplitude_cosine; /*!< Amplitude of the cosine harmonic
                                                * correction term to the orbit radius [meters] */
    double latitude_correction_amplitude_sine; /*!< Amplitude of the sine harmonic
                                                * correction term to the argument of latitude [radians] */
    double latitude_correction_amplitude_cosine; /*!< Amplitude of the cosine
                                                  * harmonic correction term to the argument of latitude [radians] */
    double inclination_correction_amplitude_sine; /*!< Amplitude of the sine harmonic
                                                   * correction term to the angle of inclination [radians] */
    double inclination_correction_amplitude_cosine; /*!< Amplitude of the cosine
                                                     * harmonic correction term to the angle of inclination [radians] */
    double mean_motion_difference; /*!< Mean motion difference. [radians/second] */
    double mean_anomaly; /*!< Mean anomaly at reference time. [radians] */
    double orbit_eccentricity; /*!< Eccentricity of satellite orbit. */
    double semi_major_axis_square_root; /*!< Square root of the semi-major axis of orbit. [meters^(1/2)] */
    double ascending_node_orbit_plane_longitude; /*!< Longitude of ascending
                                                  * node of orbit plane at weekly epoch. [radians] */
    double right_ascension_rate; /*!< Rate of right ascension. [radians/s] */
    double argument_of_perigee; /*!< Argument of perigee. [radians] */
    double inclination; /*!< Inclination. [radians] */
    double inclination_first_derivative; /*!< Inclination first derivative. [radians/s] */
    double clock_bias; /*!< Polynomial clock correction coefficient (clock bias). [seconds] */
    double clock_drift; /*!< Polynomial clock correction coefficient (clock drift). [seconds/second] */
    double clock_drift_rate; /*!< Polynomial clock correction coefficient (rate of clock drift). [seconds/second^2] */
    sbp_gps_time time_of_clock; /*!< Clock reference. */
    octet ephemeris_data_issue; /*!< Issue of ephemeris data. */
    unsigned short clock_data_issue; /*!< Issue of clock data. */
};

#pragma keylist sbp_msg_observation_ephemeris_gps header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_observation_ephemeris_gps


/**
 * @brief Satellite broadcast ephemeris for SBAS.
 *
 * The ephemeris message returns a set of satellite orbit
 * parameters that is used to calculate SBAS satellite position,
 * velocity, and clock offset.
 *
 */
struct sbp_msg_observation_ephemeris_sbas
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_gnss_signal signal_id; /*!< GNSS signal identifier */
    sbp_gps_time time_of_ephemerides; /*!< Time of Ephemerides */
    double user_range_accuracy; /*!< User Range Accuracy [meters] */
    unsigned long curve_fit_interval; /*!< Curve fit interval [seconds] */
    octet ephemeris_valid; /*!< Status of ephemeris, 1 = valid, 0 = invalid */
    octet health_bits; /*!< Satellite health status.
                        * GPS: ICD-GPS-200, chapter 20.3.3.3.1.4
                        * SBAS: 0 = valid, non-zero = invalid
                        * GLO: 0 = valid, non-zero = invalid */
    double position[3]; /*!< Position of the GEO at time toe. [meters] */
    double velocity[3]; /*!< Velocity of the GEO at time toe. [meters/second] */
    double acceleration[3]; /*!< Acceleration of the GEO at time toe [meters/second^2] */
    double geo_clock_time_offset; /*!< Time offset of the GEO clock w.r.t.
                                   * SBAS Network Time [second] */
    double geo_clock_drift; /*!< Drift of the GEO clock w.r.t.
                             * SBAS Network Time [seconds/second] */
};

#pragma keylist sbp_msg_observation_ephemeris_sbas header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_observation_ephemeris_sbas


/**
 * @brief Satellite broadcast ephemeris for GLO.
 *
 * The ephemeris message returns a set of satellite orbit
 * parameters that is used to calculate GLO satellite position,
 * velocity, and clock offset. Please see the GLO ICD 5.1 "Table 4.5
 * Characteristics of words of immediate information (ephemeris parameters)"
 * for more details.
 *
 */
struct sbp_msg_observation_ephemeris_glo
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_gnss_signal signal_id; /*!< GNSS signal identifier */
    sbp_gps_time time_of_ephemerides; /*!< Time of Ephemerides */
    double user_range_accuracy; /*!< User Range Accuracy [meters] */
    unsigned long curve_fit_interval; /*!< Curve fit interval [seconds] */
    octet ephemeris_valid; /*!< Status of ephemeris, 1 = valid, 0 = invalid */
    octet health_bits; /*!< Satellite health status.
                        * GPS: ICD-GPS-200, chapter 20.3.3.3.1.4
                        * SBAS: 0 = valid, non-zero = invalid
                        * GLO: 0 = valid, non-zero = invalid */
    double relative_carrier_frequency_deviation; /*!< Relative deviation of predicted
                                                  * carrier frequency from nominal. */
    double sv_time_correction; /*!< Correction to the SV time. [seconds] */
    double position[3]; /*!< Position of the SV at tb in PZ-90.02 coordinates system. [meters] */
    double velocity[3]; /*!< Velocity vector of the SV at tb in PZ-90.02
                         * coordinates system. [meters/second] */
    double acceleration[3]; /*!< Acceleration vector of the SV at tb in PZ-90.02
                             * coordinates system. [meters/second^2] */
};

#pragma keylist sbp_msg_observation_ephemeris_glo header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_observation_ephemeris_glo


/**
 * @brief Ionospheric corrections.
 *
 * The ionospheric parameters which allow the "L1 only" or "L2 only" user to
 * utilize the ionospheric model for computation of the ionospheric delay.
 * Please see ICD-GPS-200 (Chapter 20.3.3.5.1.7) for more details.
 *
 */
struct sbp_msg_observation_ionospheric_parameters
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_gps_time correction_table_valitidy_time; /*!< Navigation Message
                                                  * Correction Table Valitidy Time. */
    double a0; /*!< Parameter a0. */
    double a1; /*!< Parameter a1. */
    double a2; /*!< Parameter a2. */
    double a3; /*!< Parameter a3. */
    double b0; /*!< Parameter b0. */
    double b1; /*!< Parameter b1. */
    double b2; /*!< Parameter b2. */
    double b3; /*!< Parameter b3. */
};


#pragma keylist sbp_msg_observation_ionospheric_parameters header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_observation_ionospheric_parameters


/**
 * @brief GPS SV configuration.
 *
 * See ICD-GPS-200 (Chapter 20.3.3.5.1.4) for more details.
 *
 */
struct sbp_msg_observation_sv_configuration_gps
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_gps_time correction_table_valitidy_time; /*!< Navigation Message
                                                  * Correction Table Valitidy Time. */
    unsigned long l2c_capability_mask; /*!< L2C capability mask, SV32 bit
                                        * being MSB, SV1 bit being LSB. */
};

#pragma keylist sbp_msg_observation_sv_configuration_gps header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_observation_sv_configuration_gps


/**
 * @brief Group delay.
 *
 * See ICD-GPS-200 (30.3.3.3.1.1) for more details.
 *
 */
struct sbp_msg_observation_group_delay
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_gps_time prediction_time; /*!< Data Predict time of week. */
    octet pseudorandom_noise_code; /*!< Satellite number. */
    short group_delay_term; /*!< Group delay term. */
    octet group_delay_term_valid; /*!< Group delay term valid. */
    short inter_signal_correction_l1ca; /*!< ISC L1CA term. */
    octet inter_signal_correction_l1ca_valid; /*!< ISC L1CA term valid. */
    short inter_signal_correction_l2c; /*!< ISC L2C term. */
    octet inter_signal_correction_l2c_valid; /*!< ISC L2C term valid. */
};

#pragma keylist sbp_msg_observation_group_delay header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_observation_group_delay

/** \} */


/** \defgroup swiftnav_group_msg_settings Settings Messages
 *
 * Messages for reading and writing the device's device settings.
 * \{ */


/**
 * @brief Save settings to flash (host -> device).
 *
 * The save settings message persists the device's current settings
 * configuration to its on-board flash memory file system.
 *
 */
struct sbp_msg_settings_save
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    ps_guid destination_guid; /*!< Destination node GUID.
                               * For broadcast commands, use \ref PS_GUID_INVALID. */
};

#pragma keylist sbp_msg_settings_save header.src_guid, destination_guid
#pragma expose sbp_msg_settings_save


/**
 * @brief Write device configuration settings (host -> device).
 *
 * The setting message writes the device configuration.
 *
 */
struct sbp_msg_settings_write
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    ps_guid destination_guid; /*!< Destination node GUID.
                               * For broadcast commands, use \ref PS_GUID_INVALID. */
    char setting[SBP_SETTINGS_STRING_MAX_SIZE]; /*!< A NULL-terminated and delimited
                                                 * string with contents
                                                 * [SECTION_SETTING, SETTING, VALUE].
                                                 * A device will only process to
                                                 * this message when it is received
                                                 * from sender ID \ref SBP_MSG_SENDER_ID_CLIENT. */
};

#pragma cats sbp_msg_settings_write setting
#pragma keylist sbp_msg_settings_write header.src_guid, destination_guid, setting
#pragma expose sbp_msg_settings_write


/**
 * @brief Read device configuration settings (host -> device).
 *
 * The setting message reads the device configuration.
 *
 */
struct sbp_msg_settings_read_request
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    ps_guid destination_guid; /*!< Destination node GUID.
                               * For broadcast commands, use \ref PS_GUID_INVALID. */
    char setting[SBP_SETTINGS_STRING_MAX_SIZE]; /*!< A NULL-terminated and delimited
                                                 * string with contents
                                                 * [SECTION_SETTING, SETTING].
                                                 * A device will only process to
                                                 * this message when it is received
                                                 * from sender ID \ref SBP_MSG_SENDER_ID_CLIENT. */
};

#pragma cats sbp_msg_settings_read_request setting
#pragma keylist sbp_msg_settings_read_request header.src_guid, destination_guid, setting
#pragma expose sbp_msg_settings_read_request


/**
 * @brief Read device configuration settings (host <- device).
 *
 * The setting message reads the device configuration.
 *
 */
struct sbp_msg_settings_read_response
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    char setting[SBP_SETTINGS_STRING_MAX_SIZE]; /*!< A NULL-terminated and delimited
                                                 * string with contents
                                                 * [SECTION_SETTING, SETTING, VALUE]. */
};

#pragma cats sbp_msg_settings_read_response setting
#pragma keylist sbp_msg_settings_read_response header.src_guid, setting
#pragma expose sbp_msg_settings_read_response


/**
 * @brief Read setting by direct index (host -> device).
 *
 * The settings message for iterating through the settings
 * values. It will read the setting at an index, returning a
 * NULL-terminated and delimited string with contents
 * [SECTION_SETTING, SETTING, VALUE]. A device will only respond to
 * this message when it is received from sender ID \ref SBP_MSG_SENDER_ID_CLIENT.
 *
 */
struct sbp_msg_settings_read_by_index_request
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    ps_guid destination_guid; /*!< Destination node GUID.
                               * For broadcast commands, use \ref PS_GUID_INVALID. */
    unsigned short index; /*!< An index into the device settings,
                           * with values ranging from 0 to length (settings). */
};

#pragma keylist sbp_msg_settings_read_by_index_request header.src_guid, destination_guid, index
#pragma expose sbp_msg_settings_read_by_index_request


/**
 * @brief Read setting by direct index (host <- device).
 *
 * The settings message for iterating through the settings
 * values. It will read the setting at an index, returning a
 * NULL-terminated and delimited string with contents
 * [SECTION_SETTING, SETTING, VALUE].
 *
 */
struct sbp_msg_settings_read_by_index_response
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned short index; /*!< An index into the device settings,
                           * with values ranging from 0 to length (settings). */
    char setting[SBP_SETTINGS_STRING_MAX_SIZE]; /*!< A NULL-terminated and delimited
                                                 * string with contents
                                                 * [SECTION_SETTING, SETTING, VALUE]. */
};

#pragma cats sbp_msg_settings_read_by_index_response setting
#pragma keylist sbp_msg_settings_read_by_index_response header.src_guid, index, setting
#pragma expose sbp_msg_settings_read_by_index_response


/**
 * @brief Finished reading settings (host <- device).
 *
 * The settings message for indicating end of the settings values.
 *
 */
struct sbp_msg_settings_read_by_index_done
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
};

#pragma keylist sbp_msg_settings_read_by_index_done header.src_guid
#pragma expose sbp_msg_settings_read_by_index_done

/** \} */


/** \defgroup swiftnav_group_msg_ext_events External Events Messages
 *
 * Messages reporting accurately-timestamped external events, e.g. camera shutter time.
 * \{ */


/**
 * @brief Reports timestamped external pin event.
 *
 */
struct sbp_msg_external_event
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    sbp_gps_time event_timestamp; /*!< GPS time of event. */
    octet pin; /*!< Pin number. 0..9 = DEBUG0..9. */
    octet new_level; /*!< New level of pin. */
    octet time_valid; /*!< Time valid. */
};

#pragma keylist sbp_msg_external_event header.src_guid, pin, new_level
#pragma expose sbp_msg_external_event

/** \} */


/** \defgroup swiftnav_group_msg_imu Imu
 *
 * * Inertial Measurement Unit (IMU) messages.
 * \{ */

/**
 * @brief Raw IMU data.
 *
 * Raw data from the Inertial Measurement Unit, containing accelerometer and
 * gyroscope readings.
 *
 * @note The IMU data is raw, unfiltered, and unaligned IMU
 * information directly from the MEMS IMU chip.
 *
 */
struct sbp_msg_imu_raw
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< Milliseconds since start of GPS week.
                                 * If the high bit is set, the time is
                                 * unknown or invalid. [milliseconds] */
    octet time_of_week_fraction; /*!< Milliseconds since start of GPS
                                  * week, fractional part. [1/256 milliseconds] */
    short acceleration_x; /*!< Acceleration in the body frame X axis. */
    short acceleration_y; /*!< Acceleration in the body frame Y axis. */
    short acceleration_z; /*!< Acceleration in the body frame Z axis. */
    short angular_rate_x; /*!< Angular rate around the body frame X axis. */
    short angular_rate_y; /*!< Angular rate around the body frame Y axis. */
    short angular_rate_z; /*!< Angular rate around the body frame X axis. */
};

#pragma keylist sbp_msg_imu_raw header.src_guid, sensor_descriptor.id
#pragma expose sbp_msg_imu_raw

/** \} */
/**
 * @file delphi_esr_ethernet.idl
 * @brief Delphi ESR Ethernet Data Model.
 *
 * This data model reflects the Delphi ESR Ethernet XCP protocol.
 *
 * The prefix 'esr_eth' (ESR Ethernet) is used to identify data types from this module.
 *
 * Message definitions use the naming convention 'esr_eth_msg_<name>'.
 *
 */


/**
 * @brief Delphi ESR Ethernet data model major version.
 *
 * Indicates a major release version.
 *
 */
const octet DELPHI_ESR_ETHERNET_MODULE_VERSION_MAJOR = 1;


/**
 * @brief Delphi ESR Ethernet data model minor version.
 *
 * Indicates a minor release version.
 * Increased each time the syntax of the module
 * is changed (ie new or removed messages, new or removed message fields, changed number of bits, etc).
 *
 */
const octet DELPHI_ESR_ETHERNET_MODULE_VERSION_MINOR = 0;


/**
 * @brief Delphi ESR Ethernet data model sub-minor version.
 *
 * Indicates a sub-minor release version.
 * Increased each time the semantics of the
 * data model are modified (ie interpretation of field values or similar).
 *
 */
const unsigned short DELPHI_ESR_ETHERNET_MODULE_VERSION_SUBMINOR = 0;


// *****************************************************
// Type definitions
// *****************************************************


/**
 * @brief XCP scan type.
 *
 */
typedef octet esr_eth_xcp_scan_type;


// *****************************************************
// Constants
// *****************************************************


/**
 * @brief Maximum number of targets reported by the ESR Ethernet.
 *
 */
const unsigned short ESR_ETH_MAX_TARGETS = 64;


/**
 * @brief Default ESR Ethernet TCP buffer size.
 *
 */
const unsigned long ESR_ETH_DEFAULT_TCP_BUFFER_SIZE = 8568;


/**
 * @brief Default ESR Ethernet port number.
 *
 */
const unsigned long ESR_ETH_DEFAULT_TCP_PORT = 5555;


/**
 * @brief Default ESR Ethernet IP address.
 *
 */
const string ESR_ETH_DEFAULT_TCP_ADDRESS = "169.254.145.71";


/**
 * @brief XCP short scan type.
 *
 * Type \ref esr_eth_xcp_scan_type.
 *
 */
const octet ESR_ETH_XCP_SCAN_TYPE_SHORT = 0;


/**
 * @brief XCP medium scan type.
 *
 * Type \ref esr_eth_xcp_scan_type.
 *
 */
const octet ESR_ETH_XCP_SCAN_TYPE_MEDIUM = 1;


/**
 * @brief XCP long scan type.
 *
 * Type \ref esr_eth_xcp_scan_type.
 *
 */
const octet ESR_ETH_XCP_SCAN_TYPE_LONG = 2;


/**
 * @brief Number of \ref esr_eth_xcp_scan_type values.
 *
 * Type \ref esr_eth_xcp_scan_type.
 *
 */
const octet ESR_ETH_XCP_SCAN_TYPE_COUNT = 3;


// *****************************************************
// Data structures
// *****************************************************


/**
 * @brief XCP format version.
 *
 */
struct esr_eth_xcp_version
{
    unsigned short tcp_header; /*!< TCP header version. */
    unsigned short daq_definition; /*!< DAQ defintion version. */
};


/**
 * @brief Target report.
 *
 */
struct esr_eth_target_report
{
    short range; /*!< Radial range. [1/128 meters] */
    short range_rate; /*!< Radial range rate. [1/128 meters/second] */
    short theta; /*!< Radial angle. [1/128 degrees] */
    short amplitude; /*!< Detection amplitude. [1/128 Decibels] */
};


// *****************************************************
// Message types
// *****************************************************


/**
 * @brief XCP message.
 *
 */

struct esr_eth_msg_xcp
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    esr_eth_xcp_version xcp_version; /*!< XCP format version. */
    unsigned short scan_index; /*!< Scan index. */
    unsigned short tcp_size; /*!< Size of the XCP TCP data. */
    esr_eth_xcp_scan_type xcp_scan_type; /*!< XCP scan type. */
    unsigned short look_index; /*!< Look index. */
    unsigned short can_mmr_scan_index; /*!< CAN MMR Scan index. */
    short target_report_host_speed; /*!< Host speed. [1/128 meters/second] */
    short target_report_host_yaw_rate; /*!< Host yaw rate. [1/128 degrees/second] */
    unsigned long xcp_timestamp; /*!< XCP timestamp. */
    octet release_revision; /*!< DSP software version #1. */
    octet promote_revision; /*!< DSP software version #2. */
    octet field_revision; /*!< DSP software version #3. */
    unsigned short target_report_count; /*!< Number of target reports. */
    sequence<esr_eth_target_report> target_reports; /*!< Target reports. */
};

#pragma keylist esr_eth_msg_xcp header.src_guid, sensor_descriptor.id
#pragma expose esr_eth_msg_xcp
/**
 * @file leddar_vu8.idl
 * @brief Leddar Vu8 Data Model.
 *
 * This data model reflects the Leddar Vu8 CAN protocol.
 *
 * The prefix 'leddar_vu8' (Leddar Vu8) is used to identify data types from this module.
 *
 * Message definitions use the naming convention 'leddar_vu8_<name>_msg'.
 *
 */


 /**
 * @brief Leddar Vu8 data model major version.
 *
 * Indicates a major release version.
 *
 */
const octet LEDDAR_VU8_MODULE_VERSION_MAJOR = 1;


/**
 * @brief Leddar Vu8 data model minor version.
 *
 * Indicates a minor release version.
 * Increased each time the syntax of the module
 * is changed (ie new or removed messages, new or removed message fields, changed number of bits, etc).
 *
 */
const octet LEDDAR_VU8_MODULE_VERSION_MINOR = 0;


/**
 * @brief Leddar Vu8 data model sub-minor version.
 *
 * Indicates a sub-minor release version.
 * Increased each time the semantics of the
 * data model are modified (ie interpretation of field values or similar).
 *
 */
const unsigned short LEDDAR_VU8_MODULE_VERSION_SUBMINOR = 0;


// *****************************************************
// Constants
// *****************************************************


/**
 * Value used in communication with the Leddar Vu8 device. Indicates distance
 * measurent unit is meters.
 */
const unsigned short LEDDAR_VU8_UNIT_METER = 1;


/**
 * Value used in communication with the Leddar Vu8 device. Indicates distance
 * measurent unit is decimeters.
 */
const unsigned short LEDDAR_VU8_UNIT_DECIMETER = 10;


/**
 * Value used in communication with the Leddar Vu8 device. Indicates distance
 * measurent unit is centimeters.
 */
const unsigned short LEDDAR_VU8_UNIT_CENTIMETER = 100;


/**
 * Value used in communication with the Leddar Vu8 device. Indicates distance
 * measurent unit is millimeters.
 */
const unsigned short LEDDAR_VU8_UNIT_MILLIMETER = 1000;


// *****************************************************
// Type definitions
// *****************************************************


/**
 * @brief Describes the information in measurement messages that follow it.
 */
struct leddar_vu8_detection_description_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp.
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. [microseconds] */

    ps_native_timestamp native_timestamp; /*!< Native timestamp associated with
                                           * the last update.
                                           * Check \ref
                                           * ps_native_timestamp.format for
                                           * meaning.
                                           * Format value \ref
                                           * PSYNC_NATIVE_TIMESTAMP_FORMAT_INVALID
                                           * means not available. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    octet number_of_detections; /* Number of detections. */
    octet current_light_source_power; /* Current light source power as
                                       * percentage of the maximum, 100.
                                       * A value above 100 is an error.
                                       */
    unsigned short status_bit; /* Status of the bit field acquisition:
                                * Reserved. */
};
#pragma keylist leddar_vu8_detection_description_msg header.src_guid, sensor_descriptor.id
#pragma expose leddar_vu8_detection_description_msg


/**
 * @brief Measurements for one detection.
 */
struct leddar_vu8_detection_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp.
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. [microseconds]*/
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    unsigned short distance_units; /* Units of measurement expressed by the \
                                    * LEDDAR_VU8_UNIT_* constants */
    unsigned short distance; /* Distance in units defined by the distance_units
                              * field. */
    unsigned short amplitude; /* Amplitude. This value must be divided by 64 to
                               * get the amplitude (that is, 6 bits for
                               * fractional part). */
    unsigned short flags; /* Bit 0: The detection is valid (always set).
                           * Bit 1: The detection is the result of object
                           * demerging.
                           * Bit 2: Reserved.
                           * Bit 3: The detection is the saturated.
                           * Bit 4 through 15: Reserved.
                           */
    unsigned short segment_number;/* Segment number of the measurement. */
};
#pragma keylist leddar_vu8_detection_msg header.src_guid, sensor_descriptor.id
#pragma expose leddar_vu8_detection_msg
/**
 * @file xsens_mt.idl
 * @brief XSens MT Data Model.
 *
 * This data model reflects the XSens MT MTData2 protocol.
 *
 * The prefix 'xsens_mt' is used to identify data types from this module.
 *
 * Message definitions use the naming convention 'xsens_mt_<name>_msg'.
 *
 */


/**
 * @brief XSens MT data model major version.
 *
 * Indicates a major release version.
 *
 */
const octet XSENS_MT_MODULE_VERSION_MAJOR = 2;


/**
 * @brief XSens MT data model minor version.
 *
 * Indicates a minor release version.
 * Increased each time the syntax of the module
 * is changed (ie new or removed messages, new or removed message fields, changed number of bits, etc).
 *
 */
const octet XSENS_MT_MODULE_VERSION_MINOR = 0;


/**
 * @brief XSens MT data model sub-minor version.
 *
 * Indicates a sub-minor release version.
 * Increased each time the semantics of the
 * data model are modified (ie interpretation of field values or similar).
 *
 */
const unsigned short XSENS_MT_MODULE_VERSION_SUBMINOR = 0;


// *****************************************************
// Type definitions
// *****************************************************


/**
 * @brief GPS fix type.
 *
 */
typedef octet xsens_mt_gps_fix_type;


// *****************************************************
// Constants
// ****************************************************


/**
 * @brief Time of week valid.
 *
 */
const octet XSENS_MT_TIME_OF_WEEK_VALID = 0x01;


/**
 * @brief Week number valid.
 *
 */
const octet XSENS_MT_WEEK_NUMBER_VALID = 0x02;


/**
 * @brief UTC time valid.
 *
 */
const octet XSENS_MT_UTC_VALID = 0x04;


/**
 * @brief Valid fix (within DOP and accuracy masks).
 *
 */
const octet XSENS_MT_GPS_FIX_STATUS_VALID = 0x01;


/**
 * @brief DGPS used.
 *
 */
const octet XSENS_MT_GPS_FIX_STATUS_DGPS = 0x02;


/**
 * @brief Valid week number.
 *
 */
const octet XSENS_MT_GPS_FIX_STATUS_WEEK_NUMBER_VALID = 0x04;


/**
 * @brief Valid time of week.
 *
 */
const octet XSENS_MT_GPS_FIX_STATUS_TIME_OF_WEEK_VALID = 0x08;


/**
 * @brief No fix.
 *
 * Type \ref xsens_mt_gps_fix_type.
 *
 */
const xsens_mt_gps_fix_type XSENS_MT_GPS_FIX_TYPE_NONE = 0;


/**
 * @brief Dead reckoning only.
 *
 * Type \ref xsens_mt_gps_fix_type.
 *
 */
const xsens_mt_gps_fix_type XSENS_MT_GPS_FIX_TYPE_DEAD_RECKONING = 1;


/**
 * @brief 2D fix.
 *
 * Type \ref xsens_mt_gps_fix_type.
 *
 */
const xsens_mt_gps_fix_type XSENS_MT_GPS_FIX_TYPE_2D = 2;


/**
 * @brief 3D fix.
 *
 * Type \ref xsens_mt_gps_fix_type.
 *
 */
const xsens_mt_gps_fix_type XSENS_MT_GPS_FIX_TYPE_3D = 3;


/**
 * @brief GPS and dead reckoning combined.
 *
 * Type \ref xsens_mt_gps_fix_type.
 *
 */
const xsens_mt_gps_fix_type XSENS_MT_GPS_FIX_TYPE_GPS_DEAD_RECKONING = 4;


/**
 * @brief Number of \ref xsens_mt_gps_fix_type values.
 *
 * Type \ref xsens_mt_gps_fix_type.
 *
 */
const xsens_mt_gps_fix_type XSENS_MT_GPS_FIX_TYPE_COUNT = 5;


/**
 * @brief Maximum number of \ref xsens_mt_gps_sv_info_channel's provided by \ref xsens_mt_gps_sv_info_msg.
 *
 */
const unsigned long XSENS_MT_MAX_GPS_SV_INFO_CHANNELS = 16;


/**
 * @brief Maximum number of \ref xsens_mt_gnss_satellite_info's channels provided by \ref xsens_mt_gnss_satellite_info_msg.
 *
 */
const unsigned long XSENS_MT_MAX_GNSS_SATELLITE_INFOS = 60;


// *****************************************************
// Data structures
// *****************************************************


/**
 * @brief GPS space vehicle information channel.
 *
 */
struct xsens_mt_gps_sv_info_channel
{
    octet channel_number; /*!< Channel number, 255 for SVs not assigned to a channel. */
    octet satellite_id; /*!< Satellite identifier. */
    octet flags; /*!< Bitmask, made up of the following bit values:
                  * \li bit 0 = SV is used for navigation
                  * \li bit 1 = differential correction data is available for SV
                  * \li bit 2 = orbit information is available for SV
                  * \li bit 3 = orbit information is Ephemeris
                  * \li bit 4 = SV is unhealthy / shall not be used */
    octet quality; /*!< Signal quality indicator:
                    * \li 0 = channel is idle
                    * \li 1, 2 = channel is searching
                    * \li 3 = signal detected but unusable
                    * \li 4 = code lock on signal
                    * \li 5, 6 = code and carrier locked
                    * \li 7 = code and carrier locked, receiving 50bps data */
    octet signal_strength; /*!< Carrier to noise ratio. [dbHz] */
    short elevation; /*!< Integer elevation. [degrees] */
    short azimuth; /*!< Integer azimuth. [degrees] */
    long pseudo_range_residual; /*!< Pseudo range residual. [centimeters] */
};


/**
 * @brief GNSS satellite information.
 *
 */
struct xsens_mt_gnss_satellite_info
{
    octet gnss_id; /*!< GNSS identifier.
                    * \li 0 = GPS
                    * \li 1 = SBAS
                    * \li 2 = Galileo
                    * \li 3 = BeiDou
                    * \li 4 = IMES
                    * \li 5 = QZSS
                    * \li 6 = GLONASS */
    octet satellite_id; /*!< Satellite identifier. */
    octet signal_strength; /*!< Carrier to noise ratio. [dbHz] */
    octet flags; /*!< Flags:
                  * \li bit 0..2 = signal quality indicator
                  *   - 0 = no signal
                  *   - 1 = searching signal
                  *   - 2 = signal acquired
                  *   - 3 = signal detected but unusable
                  *   - 4 = code locked and time synchronised
                  *   - 5, 6, 7 = code & carrier locked; time synchronised
                  * \li bit 3 = SV is being used for navigation
                  * \li bit 4..5 = SV health flag
                  *   - 0 = unknown
                  *   - 1 = healthy
                  *   - 2 = unhealthy
                  * \li bit 6 = differential correction data is available
                  * \li bit 7 = reserved */
};


// *****************************************************
// Message types
// *****************************************************


/**
 * @brief Contains the internal temperature of the sensor in degrees Celsius.
 *
 */
struct xsens_mt_temperature_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double temperature; /*!< Internal temperature of the sensor. [degrees Celsius] */
};
#pragma keylist xsens_mt_temperature_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_temperature_msg


/**
 * @brief Contains the timestamp expressed as the UTC time.
 *
 * Time till UTC flag (0x04) goes to valid takes 12.5 minutes.
 * This time is needed to correct for the clock bias of the receiver.
 * It is advised to start synchronization using UTC only when the UTC flag is valid.
 *
 */
struct xsens_mt_utc_time_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned short year; /*!< Year. */
    octet month; /*!< Month (range 1 to 12). */
    octet day; /*!< Days in the month (range 1 to 31). */
    octet hours; /*!< Hours of the day (range 0 to 23). */
    octet minutes; /*!< Minutes of the hour (range 0 to 59). */
    octet seconds; /*!< Seconds of the minute (range 0 to 60). */
    unsigned long nanoseconds; /*!< Nanosecond residual. [nanoseconds] */
    octet flags; /*!< Validity flags.
                  *
                  * \li \ref XSENS_MT_TIME_OF_WEEK_VALID = 0x01
                  * \li \ref XSENS_MT_WEEK_NUMBER_VALID = 0x02
                  * \li \ref XSENS_MT_UTC_VALID = 0x04 */
};
#pragma keylist xsens_mt_utc_time_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_utc_time_msg


/**
 * @brief Contains the timestamp expressed as the GPS time of week.
 *
 * The number is the number of milliseconds since the start of the week.
 *
 */
struct xsens_mt_time_of_week_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< Number of milliseconds since the start of the week. [milliseconds] */
};
#pragma keylist xsens_mt_time_of_week_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_time_of_week_msg


/**
 * @brief Contains the packet counter.
 *
 * This counter is incremented with every generated MTData2 message.
 *
 */
struct xsens_mt_packet_counter_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned short packet_counter; /*!< MTData2 packet count. */
};
#pragma keylist xsens_mt_packet_counter_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_packet_counter_msg


/**
 * @brief Contains the sample time of an output expressed in 10kHz ticks.
 *
 * When there is no GNSS-fix in the MTi-G-700/MTi-G-710, this value is arbitrary for GNSS messages.
 *
 */
struct xsens_mt_sample_time_fine_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long sample_time; /*!< Sample time. [10 kHz ticks] */
};
#pragma keylist xsens_mt_sample_time_fine_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_sample_time_fine_msg


/**
 * @brief Contains the sample time of an output expressed in seconds.
 *
 * When there is no GNSS-fix in the MTi-G-700/MTi-G-710, this value is arbitrary for GNSS messages.
 *
 */
struct xsens_mt_sample_time_coarse_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long sample_time; /*!< Sample time. [seconds] */
};
#pragma keylist xsens_mt_sample_time_coarse_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_sample_time_coarse_msg


/**
 * @brief Contains orientation output expressed as a quaternion.
 *
 */
struct xsens_mt_quaternion_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double orientation[4]; /*!< Orientation quaternion Q0/Q1/Q2/Q3. */
};
#pragma keylist xsens_mt_quaternion_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_quaternion_msg


/**
 * @brief Contains orientation output expressed as Euler angles.
 *
 */
struct xsens_mt_euler_angles_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double orientation[3]; /*!< Orientation Euler angles. [rpy degrees] */
};
#pragma keylist xsens_mt_euler_angles_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_euler_angles_msg


/**
 * @brief Contains orientation output expressed as rotation matrix (DCM).
 *
 */
struct xsens_mt_rotation_matrix_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double orientation[9]; /*!< Rotation matrix (a:i). */
};
#pragma keylist xsens_mt_rotation_matrix_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_rotation_matrix_msg


/**
 * @brief Contains the pressure as measured by the internal barometer.
 *
 */
struct xsens_mt_barometric_pressure_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long pressure; /*!< Barometric pressure. [Pascal] */
};
#pragma keylist xsens_mt_barometric_pressure_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_barometric_pressure_msg


/**
 * @brief Contains the delta velocity value of the SDI output.
 *
 */
struct xsens_mt_delta_velocity_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double delta_velocity[3]; /*!< Delta velocity. [xyz meters/second] */
};
#pragma keylist xsens_mt_delta_velocity_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_delta_velocity_msg


/**
 * @brief Contains the delta quaternion value of the SDI output.
 *
 */
struct xsens_mt_delta_quaternion_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double delta_quaternion[4]; /*!< Delta quaternion Q0/Q1/Q2/Q3. */
};
#pragma keylist xsens_mt_delta_quaternion_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_delta_quaternion_msg


/**
 * @brief Contains the calibrated acceleration vector.
 *
 */
struct xsens_mt_acceleration_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double acceleration[3]; /*!< Acceleration. [xyz meters/second^2] */
};
#pragma keylist xsens_mt_acceleration_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_acceleration_msg


/**
 * @brief Contains the free acceleration vector.
 *
 */
struct xsens_mt_free_acceleration_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double acceleration[3]; /*!< Acceleration. [xyz meters/second^2] */
};
#pragma keylist xsens_mt_free_acceleration_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_free_acceleration_msg


/**
 * @brief Contains the calibrated acceleration vector.
 *
 * Output data rate is 1000 Hz, direct output from the digital inertial sensors.
 *
 */
struct xsens_mt_acceleration_hr_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double acceleration[3]; /*!< Acceleration. [xyz meters/second^2] */
};
#pragma keylist xsens_mt_acceleration_hr_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_acceleration_hr_msg


/**
 * @brief Contains the calibrated rate of turn vector.
 *
 */
struct xsens_mt_rate_of_turn_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double rate_of_turn[3]; /*!< Rate of turn. [xyz radians/second] */
};
#pragma keylist xsens_mt_rate_of_turn_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_rate_of_turn_msg


/**
 * @brief Contains the calibrated rate of turn vector.
 *
 * Output data rate is 1000 Hz, direct output from the digital inertial sensors.
 *
 */
struct xsens_mt_rate_of_turn_hr_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double rate_of_turn[3]; /*!< Rate of turn. [xyz radians/second] */
};
#pragma keylist xsens_mt_rate_of_turn_hr_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_rate_of_turn_hr_msg


/**
 * @brief Contains the un-calibrated raw data output.
 *
 * Contains the accelerations, rate of turn and magnetic field in x, y and z axes.
 * These values are equal to the analog-digital converter readings of the
 * internal sensors. The message also include the value of the internal temperature sensor.
 *
 */
struct xsens_mt_raw_acc_gyro_mag_temp_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned short acceleration[3]; /*!< Raw acceleration. [xyz raw] */
    unsigned short rate_of_turn[3]; /*!< Raw rate of turn. [xyz raw] */
    unsigned short magnetic_field[3]; /*!< Raw magnetic field. [xyz raw] */
    short temperature; /*!< Raw temperature. [1/256 degrees Celsius] */
};
#pragma keylist xsens_mt_raw_acc_gyro_mag_temp_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_raw_acc_gyro_mag_temp_msg


/**
 * @brief Contains the values of the gyroscope temperature sensors.
 *
 */
struct xsens_mt_raw_gyro_temp_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    short temperature[3]; /*!< Raw gyroscope temperatures. [xyz 1/256 degrees Celsius] */
};
#pragma keylist xsens_mt_raw_gyro_temp_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_raw_gyro_temp_msg


/**
 * @brief Contains the calibrated magnetic field vector.
 *
 */
struct xsens_mt_magnetic_field_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double magnetic_field[3]; /*!< Magnetic field. [xyz normalized] */
};
#pragma keylist xsens_mt_magnetic_field_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_magnetic_field_msg


/**
 * @brief Contains the position in the Earth-Centered, Earth-Fixed (ECEF) coordinate system.
 *
 */
struct xsens_mt_position_ecef_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double position[3]; /*!< ECEF position. [xyz meters] */
};
#pragma keylist xsens_mt_position_ecef_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_position_ecef_msg


/**
 * @brief Contains the latitude and longitude position.
 *
 */
struct xsens_mt_position_latlon_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double latitude; /*!< Latitude. [degrees] */
    double longitude; /*!< Longitude. [degrees] */
};
#pragma keylist xsens_mt_position_latlon_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_position_latlon_msg


/**
 * @brief Contains the altitude in meters above the WGS-84 Ellipsoid.
 *
 */
struct xsens_mt_altitude_ellipsoid_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double altitude; /*!< Altitude above the WGS-84 Ellipsoid. [meters] */
};
#pragma keylist xsens_mt_altitude_ellipsoid_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_altitude_ellipsoid_msg


/**
 * @brief Contains the velocity vector.
 *
 */
struct xsens_mt_velocity_xyz_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double velocity[3]; /*!< Velocity. [xyz meters/second] */
};
#pragma keylist xsens_mt_velocity_xyz_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_velocity_xyz_msg


/**
 * @brief Contains the 8bit status byte.
 *
 * Equal to bits 0:7 of the status word, see \ref xsens_mt_status_word_msg.
 *
 * \li bit 0 - Selftest
 *    This flag indicates if the MT passed the latest self-test.
 * \li bit 1 - Filter valid
 *    This flag indicates if input into the orientation filter is reliable
 *    and / or complete. If for example the measurement range of
 *    internal sensors is exceeded, orientation output cannot be
 *    reliably estimated and the filter flag will drop to 0. For the MTiG,
 *    the filter flag will also become invalid if the GPS status
 *    remains invalid for an extended period
 * \li bit 2 - GNSS fix
 *    This flag indicates if the GNSS unit has a proper fix.
 *    The flag is only available in MTi-G units.
 * \li bit 3:4 - No rotation update status
 *    This flag indicates the status of the no rotation update
 *    procedure in the filter after the SetNoRotation message has
 *    been sent.
 *      - 11: Running with no rotation assumption
 *      - 10: Rotation detected, no gyro bias estimation (sticky)
 *      - 00: Estimation complete, no errors
 * \li bit 5 - Representative motion (RepMo)
 *    Indicates if the MTi is in In-run Compass Calibration Representative Mode.
 * \li bit 6:7 - Reserved
 *
 */
struct xsens_mt_status_byte_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    octet status; /*!< Status byte. */
};
#pragma keylist xsens_mt_status_byte_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_status_byte_msg


/**
 * @brief Contains the 32bit status word.
 *
 * \li bit 0 - Selftest
 *    This flag indicates if the MT passed the latest self-test.
 * \li bit 1 - Filter valid
 *    This flag indicates if input into the orientation filter is reliable
 *    and / or complete. If for example the measurement range of
 *    internal sensors is exceeded, orientation output cannot be
 *    reliably estimated and the filter flag will drop to 0. For the MTiG,
 *    the filter flag will also become invalid if the GPS status
 *    remains invalid for an extended period
 * \li bit 2 - GNSS fix
 *    This flag indicates if the GNSS unit has a proper fix.
 *    The flag is only available in MTi-G units.
 * \li bit 3:4 - No rotation update status
 *    This flag indicates the status of the no rotation update
 *    procedure in the filter after the SetNoRotation message has
 *    been sent.
 *      - 11: Running with no rotation assumption
 *      - 10: Rotation detected, no gyro bias estimation (sticky)
 *      - 00: Estimation complete, no errors
 * \li bit 5 - Representative motion (RepMo)
 *    Indicates if the MTi is in In-run Compass Calibration Representative Mode.
 * \li bit 6:7 - Reserved
 * \li bit 8 - Clipflag Acc X
 *    If set an out of range acceleration on the X axis is detected.
 * \li bit 9 - Clipflag Acc Y
 *    If set an out of range acceleration on the Y axis is detected.
 * \li bit 10 - Clipflag Acc Z
 *    If set an out of range acceleration on the Z axis is detected.
 * \li bit 11 - Clipflag Gyr X
 *    If set an out of range angular velocity on the X axis is detected.
 * \li bit 12 - Clipflag Gyr Y
 *    If set an out of range angular velocity on the Y axis is detected.
 * \li bit 13 - Clipflag Gyr Z
 *    If set an out of range angular velocity on the Z axis is detected.
 * \li bit 14 - Clipflag Mag X
 *    If set an out of range magnetic field on the X axis is detected.
 * \li bit 15 - Clipflag Mag Y
 *    If set an out of range magnetic field on the Y axis is detected.
 * \li bit 16 - Clipflag Mag Z
 *    If set an out of range magnetic field on the Z axis is detected.
 * \li bit 17:18 - Reserved
 * \li bit 19 - Clipping indication
 *    This flag indicates going out of range of one of the sensors
 *    (is set when one or more bits from 8:16 are set).
 * \li bit 20 - Reserved
 * \li bit 21 - SyncIn Marker
 *    When a SyncIn is detected, this bit will rise to 1.
 * \li bit 22 - SyncOut Marker
 *    When SyncOut is active this bit will rise to 1.
 * \li bit 23:25 - Filter Mode
 *    Indicates Filter Mode, currently only available for MTi-G-700/710:
 *      - 000: Without GNSS (filter profile is in VRU mode)
 *      - 001: Coasting mode (GNSS has been lost <60 sec ago)
 *      - 011: With GNSS (default mode of MTi-G-700/MTi-G-710)
 * \li bit 26:31 - Reserved
 *
 */
struct xsens_mt_status_word_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long status; /*!< Status word. */
};
#pragma keylist xsens_mt_status_word_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_status_word_msg


/**
 * @brief Contains the dilution of precision (DOP) values for the most recent GPS position.
 *
 * This data comes directly from the on-board GPS module.
 *
 * @note All DOP values are scaled by a factor of 100, and are dimensionless.
 *
 */
struct xsens_mt_gps_dop_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    unsigned short gdop; /*!< Geometric dilution of precision. [0.01] */
    unsigned short pdop; /*!< Position dilution of precision. [0.01] */
    unsigned short tdop; /*!< Time dilution of precision. [0.01] */
    unsigned short vdop; /*!< Vertical dilution of precision. [0.01] */
    unsigned short hdop; /*!< Horizontal dilution of precision. [0.01] */
    unsigned short ndop; /*!< Northing dilution of precision. [0.01] */
    unsigned short edop; /*!< Easting dilution of precision. [0.01] */
};
#pragma keylist xsens_mt_gps_dop_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_gps_dop_msg


/**
 * @brief Contains the navigation solution information of the on-board GPS.
 *
 * This data comes directly from the on-board GPS module.
 *
 */
struct xsens_mt_gps_sol_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week rounded to the nearest millisecond. [milliseconds] */
    long residual; /*!< Nanosecond residual of millisecond-rounded time-of-week (ranges -500,000 to 500,000). [nanoseconds] */
    unsigned short week; /*!< GPS week number. */
    xsens_mt_gps_fix_type fix_type; /*!< GPS fix type. */
    octet flags; /*!< Fix status flags. See \ref XSENS_MT_GPS_FIX_STATUS_VALID. */
    long x; /*!< ECEF X coordinate. [centimeters] */
    long y; /*!< ECEF Y coordinate. [centimeters] */
    long z; /*!< ECEF Z coordinate. [centimeters] */
    unsigned long position_accuracy; /*!< 3D position accuracy estimate. [centimeters] */
    long vx; /*!< Velocity ECEF X coordinate. [centimeters/second] */
    long vy; /*!< Velocity ECEF Y coordinate. [centimeters/second] */
    long vz; /*!< Velocity ECEF Z coordinate. [centimeters/second] */
    unsigned long speed_accuracy; /*!< Speed accuracy estimate. [centimeters/second] */
    unsigned short pdop; /*!< Position dilution of precision. [0.01] */
    octet sv_count; /*!< Number of SVs used in the navigation solution. */
};
#pragma keylist xsens_mt_gps_sol_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_gps_sol_msg


/**
 * @brief Contains the UTC time solution coming directly from the on-board GPS module.
 *
 */
struct xsens_mt_gps_time_utc_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week rounded to the nearest millisecond. [milliseconds] */
    long residual; /*!< Nanosecond residual of millisecond-rounded time-of-week (ranges -500,000 to 500,000). [nanoseconds] */
    unsigned long time_accuracy; /*!< Time accuracy estimate. [nanoseconds] */
    unsigned short year; /*!< Year. */
    octet month; /*!< Month (range 1 to 12). */
    octet day; /*!< Days in the month (range 1 to 31). */
    octet hours; /*!< Hours of the day (range 0 to 23). */
    octet minutes; /*!< Minutes of the hour (range 0 to 59). */
    octet seconds; /*!< Seconds of the minute (range 0 to 60). */
    octet valid_flags; /*!< Validity flags.
                        *
                        * \li bit 0 - UTC date is valid
                        * \li bit 1 - UTC time of day i valid
                        * \li bit 2 - UTC time of day has been fully resolved */
};
#pragma keylist xsens_mt_gps_time_utc_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_gps_time_utc_msg


/**
 * @brief Contains the space vehicle information as reported directly by the on-board GPS module.
 *
 */
struct xsens_mt_gps_sv_info_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    sequence<xsens_mt_gps_sv_info_channel> channels; /*!< Channels. */
};
#pragma keylist xsens_mt_gps_sv_info_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_gps_sv_info_msg


/**
 * @brief Contains the position, velocity, and time information as reported directly by the on-board GPS module.
 *
 */
struct xsens_mt_gnss_pvt_data_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    unsigned short year; /*!< Year. */
    octet month; /*!< Month (range 1 to 12). */
    octet day; /*!< Days in the month (range 1 to 31). */
    octet hours; /*!< Hours of the day (range 0 to 23). */
    octet minutes; /*!< Minutes of the hour (range 0 to 59). */
    octet seconds; /*!< Seconds of the minute (range 0 to 60). */
    long residual; /*!< Nanosecond residual of millisecond-rounded time-of-week (ranges -500,000 to 500,000). [nanoseconds] */
    unsigned long time_accuracy; /*!< Time accuracy estimate. [nanoseconds] */
    octet valid_flags; /*!< Validity flags.
                        *
                        * \li bit 0 - UTC date is valid
                        * \li bit 1 - UTC time of day i valid
                        * \li bit 2 - UTC time of day has been fully resolved */
    xsens_mt_gps_fix_type fix_type; /*!< GPS fix type. */
    octet flags; /*!< Fix status flags.
                  * \li bit 0 = valid fix (within DOP and accuracy masks)
                  * \li bit 1 = differential corrections are applied
                  * \li bit 2..4 = reserved (ignore)
                  * \li bit 5 = heading of vehicle is valid */
    octet satellite_count; /*!< Number of satellites used in the navigation solution. */
    long pvt_longitude; /*!< Longitude. [1e-7 degrees] */
    long pvt_latitude; /*!< Latitude. [1e-7 degrees] */
    long height; /*!< Height above ellipsoid. [millimeters] */
    long height_msl; /*!< Height above mean sea level. [millimeters] */
    unsigned long horizontal_accuracy; /*!< Horizontal accuracy estimate. [millimeters] */
    unsigned long vertical_accuracy; /*!< Vertical accuracy estimate. [millimeters] */
    long velocity_north; /*!< NED North velocity. [millimeters/second] */
    long velocity_east; /*!< NED East velocity. [millimeters/second] */
    long velocity_down; /*!< NED Down velocity. [millimeters/second] */
    long ground_speed; /*!< 2D speed over ground. [millimeters/second] */
    long motion_heading; /*!< 2D heading of motion. [1e-5 degrees] */
    unsigned long speed_accuracy; /*!< Speed accuracy estimate. [millimeters/second] */
    unsigned long heading_accuracy; /*!< Heading accuracy estimate. [degrees] */
    long vehicle_heading; /*!< 2D heading of vehicle. [1e-5 degrees] */
    unsigned short gdop; /*!< Geometric dilution of precision. [0.01] */
    unsigned short pdop; /*!< Position dilution of precision. [0.01] */
    unsigned short tdop; /*!< Time dilution of precision. [0.01] */
    unsigned short vdop; /*!< Vertical dilution of precision. [0.01] */
    unsigned short hdop; /*!< Horizontal dilution of precision. [0.01] */
    unsigned short ndop; /*!< Northing dilution of precision. [0.01] */
    unsigned short edop; /*!< Easting dilution of precision. [0.01] */
};
#pragma keylist xsens_mt_gnss_pvt_data_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_gnss_pvt_data_msg


/**
 * @brief Contains the GNSS satellite information as reported directly by the on-board GPS module.
 *
 */
struct xsens_mt_gnss_satellite_info_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long time_of_week; /*!< GPS time of week. [milliseconds] */
    sequence<xsens_mt_gnss_satellite_info> infos; /*!< Satellite infos. */
};
#pragma keylist xsens_mt_gnss_satellite_info_msg header.src_guid, sensor_descriptor.id
#pragma expose xsens_mt_gnss_satellite_info_msg

/**
 * @file vectornav_vn300.idl
 * @brief VectorNav VN-300 Data Model.
 *
 * The prefix 'vn300' is used to identify data types from this module.
 *
 * Message definitions use the naming convention 'vn300_<name>_msg'.
 *
 */


/**
 * @brief VectorNav VN-300 data model major version.
 *
 * Indicates a major release version.
 *
 */
const octet VECTORNAV_VN300_MODULE_VERSION_MAJOR = 2;


/**
 * @brief VectorNav VN-300 data model minor version.
 *
 * Indicates a minor release version.
 * Increased each time the syntax of the module
 * is changed (ie new or removed messages,
 * new or removed message fields, changed number of bits, etc).
 *
 */
const octet VECTORNAV_VN300_MODULE_VERSION_MINOR = 0;


/**
 * @brief VectorNav VN-300 data model sub-minor version.
 *
 * Indicates a sub-minor release version.
 * Increased each time the semantics of the
 * data model are modified (ie interpretation of field values or similar).
 *
 */
const unsigned short VECTORNAV_VN300_MODULE_VERSION_SUBMINOR = 0;


// *****************************************************
// Message types
// *****************************************************


/**
 * @brief The system time since startup.
 *
 * The time since startup is based upon the
 * internal TXCO oscillator for the MCU.
 * The accuracy of the internal TXCO is +/- 20ppm (-40C to 85C).
 *
 */
struct vn300_time_startup_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long long time; /*!< System time since startup. [nanoseconds] */
};
#pragma keylist vn300_time_startup_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_time_startup_msg


/**
 * @brief The absolute GPS time since start of GPS epoch 1980.
 *
 */
struct vn300_time_gps_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long long time; /*!< Absolute GPS time. [nanoseconds] */
};
#pragma keylist vn300_time_gps_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_time_gps_msg


/**
 * @brief The time since the last sync-in trigger event.
 *
 */
struct vn300_time_sync_in_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long long time; /*!< Time since the last sync-in trigger. [nanoseconds] */
};
#pragma keylist vn300_time_sync_in_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_time_sync_in_msg


/**
 * @brief The estimated attitude yaw, pitch, and roll angles.
 *
 * The attitude is given as a 3,2,1 Euler angle sequence
 * describing the body frame with respect to the
 * local North East Down (NED) frame.
 *
 */
struct vn300_yaw_pitch_roll_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double yaw; /*!< Orientation yaw angle. [degrees] */
    double pitch; /*!< Orientation pitch angle. [degrees] */
    double roll; /*!< Orientation roll angle. [degrees] */
};
#pragma keylist vn300_yaw_pitch_roll_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_yaw_pitch_roll_msg


/**
 * @brief The estimated attitude quaternion.
 *
 * The last term is the scalar value. The attitude is given as
 * the body frame with respect to the local North East Down (NED) frame.
 *
 */
struct vn300_quaternion_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double orientation[4]; /*!< Orientation quaternion Q0/Q1/Q2/Q3. */
};
#pragma keylist vn300_quaternion_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_quaternion_msg


/**
 * @brief The estimated angular rate.
 *
 * The angular rates are compensated by the onboard filter
 * bias estimates. The angular rate is expressed in the body frame.
 *
 */
struct vn300_angular_rate_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double angular_rate[3]; /*!< Rate of turn. [xyz radians/second] */
};
#pragma keylist vn300_angular_rate_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_angular_rate_msg


/**
 * @brief The estimated position given as latitude, longitude, and altitude.
 *
 */
struct vn300_position_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double latitude; /*!< Latitude. [degrees] */
    double longitude; /*!< Longitude. [degrees] */
    double altitude; /*!< Altitude. [meters] */
};
#pragma keylist vn300_position_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_position_msg


/**
 * @brief The estimated velocity in the North East Down (NED) frame.
 *
 */
struct vn300_velocity_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double velocity[3]; /*!< Velocity. [NED meters/second] */
};
#pragma keylist vn300_velocity_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_velocity_msg


/**
 * @brief The estimated acceleration in the body frame.
 *
 * This acceleration includes gravity and has
 * been bias compensated by the onboard INS Kalman filter.
 *
 */
struct vn300_acceleration_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double acceleration[3]; /*!< Acceleration. [xyz meters/second^2] */
};
#pragma keylist vn300_acceleration_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_acceleration_msg


/**
 * @brief The uncompensated IMU acceleration and angular rate measurements.
 *
 * These measurements correspond to the calibrated angular
 * rate and acceleration measurements straight from the IMU.
 * The measurements have not been corrected for bias
 * offset by the onboard Kalman filter.
 *
 */
struct vn300_imu_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double acceleration[3]; /*!< Acceleration. [xyz meters/second^2] */
    double angular_rate[3]; /*!< Rate of turn. [xyz radians/second] */
};
#pragma keylist vn300_imu_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_imu_msg


/**
 * @brief The compensated magnetic, temperature, and pressure measurements from the IMU.
 *
 * The magnetic measurement is given in Gauss, and has been corrected for
 * hard/soft iron corrections (if enabled).
 *
 */
struct vn300_mag_temp_pres_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double magnetic_field[3]; /*!< Magnetic field. [xyz Gauss] */
    double temperature; /*!< Temperature. [Celsius] */
    double pressure; /*!< Pressure. [kPa] */
};
#pragma keylist vn300_mag_temp_pres_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_mag_temp_pres_msg


/**
 * @brief The delta time, angle, and velocity measurements.
 *
 * The delta time is the time interval that the delta angle
 * and velocities are integrated over. The delta theta
 * is the delta rotation angles incurred due to rotation, since
 * the last time the values were outputted by the device.
 * The delta velocity is the delta velocity incurred due to
 * motion, since the last time the values were outputted by
 * the device. These delta angles and delta velocities are
 * calculated based upon the onboard coning and sculling
 * integration performed onboard the sensor at the
 * IMU rate (default 800Hz). The integration for both
 * the delta angles and velocities are reset each time
 * either of the values are either polled or sent out
 * due to a scheduled asynchronous ASCII or binary output.
 *
 */
struct vn300_delta_theta_velocity_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    double delta_time; /*!< Delta time. [seconds] */
    double delta_theta[3]; /*!< Delta velocity. [xyz degrees] */
    double delta_velocity[3]; /*!< Delta velocity. [xyz meters/second] */
};
#pragma keylist vn300_delta_theta_velocity_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_delta_theta_velocity_msg


/**
 * @brief The INS status bitfield.
 *
 */
struct vn300_ins_status_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned short ins_status; /*!< INS status bitfield. */
};
#pragma keylist vn300_ins_status_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_ins_status_msg


/**
 * @brief The number of sync-in trigger events that have occurred.
 *
 */
struct vn300_sync_in_count_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long count; /*!< Number of sync-in trigger events that have occurred. */
};
#pragma keylist vn300_sync_in_count_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_sync_in_count_msg


/**
 * @brief The time since the last GPS PPS trigger event.
 *
 */
struct vn300_time_gps_pps_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp. [microseconds]
                                *
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. */
    unsigned long long time; /*!< Time since the last GPS PPS trigger event. [nanoseconds] */
};
#pragma keylist vn300_time_gps_pps_msg header.src_guid, sensor_descriptor.id
#pragma expose vn300_time_gps_pps_msg
/**
 * @file oscc.idl
 * @brief PolySync OSCC Data Model.
 *
 * This data model reflects the OSCC protocol.
 *
 * The prefix 'oscc' is used to identify data types from this module.
 *
 * Message definitions use the naming convention 'oscc_<name>_msg'.
 *
 */


 /**
 * @brief OSCC data model major version.
 *
 * Indicates a major release version.
 *
 */
const octet OSCC_MODULE_VERSION_MAJOR = 1;


/**
 * @brief OSCC data model minor version.
 *
 * Indicates a minor release version.
 * Increased each time the syntax of the module
 * is changed (ie new or removed messages, new or removed message fields,
 * changed number of bits, etc).
 *
 */
const octet OSCC_MODULE_VERSION_MINOR = 1;


/**
 * @brief OSCC data model sub-minor version.
 *
 * Indicates a sub-minor release version.
 * Increased each time the semantics of the
 * data model are modified (ie interpretation of field values or similar).
 *
 */
const unsigned short OSCC_MODULE_VERSION_SUBMINOR = 0;


// *****************************************************
// Type definitions
// *****************************************************


/**
 * @brief Fault origin type.
 *
 */
typedef unsigned long oscc_fault_origin_id;


// *****************************************************
// Constants
// *****************************************************


/**
 * @brief First magic byte used in commands and reports.
 *
 * The magic word is used to distinguish CAN frame as
 * coming from OSCC (and not OBD).
 *
 */
const octet OSCC_MAGIC_WORD_BYTE_0 = 0x05;


/**
 * @brief Second magic byte used in commands and reports.
 *
 * The magic word is used to distinguish CAN frame as
 * coming from OSCC (and not OBD).
 *
 */
const octet OSCC_MAGIC_WORD_BYTE_1 = 0xCC;


/**
 * @brief Fault originated from the brake module/controls.
 *
 */
const oscc_fault_origin_id OSCC_FAULT_ORIGIN_BRAKE = 0;


/**
 * @brief Fault originated from the steering module/controls.
 *
 */
const oscc_fault_origin_id OSCC_FAULT_ORIGIN_STEERING = 1;


/**
 * @brief Fault originated from the throttle module/controls.
 *
 */
const oscc_fault_origin_id OSCC_FAULT_ORIGIN_THROTTLE = 2;


// *****************************************************
// Message types
// *****************************************************


/**
 * @brief Enable/disable controls message.
 *
 */
struct oscc_enable_disable_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_guid dest_guid; /*!< Destination GUID.
                        * Value \ref PSYNC_GUID_INVALID means not used. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp associated with the control command.
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. [microseconds] */
    octet enable_control; /*!< Controls enabled state.
                           * Value zero means controls will be disabled.
                           * Non-zero value means controls will be enabled. */
};
#pragma keylist oscc_enable_disable_msg header.src_guid dest_guid
#pragma expose oscc_enable_disable_msg


/**
 * @brief Brake report message.
 *
 */
struct oscc_brake_report_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp.
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. [microseconds] */
    octet magic[2]; /*!< Magic number identifying CAN frame as from OSCC.
                     * Byte 0 should be \ref OSCC_MAGIC_WORD_BYTE_0.
                     * Byte 1 should be \ref OSCC_MAGIC_WORD_BYTE_1. */
    octet enabled; /*!< Braking controls enabled state.
                      * Zero value means disabled (commands are ignored).
                      * Non-zero value means enabled (no timeouts or overrides
                      * have occured). */
    octet operator_override; /*!< Driver override state.
                                * Zero value means there has been no operator
                                * override. Non-zero value means an operator
                                * has physically overridden the system. */
    octet dtcs; /*!< Bitfield of DTCs present in the module. */
    octet reserved[3]; /*!< Reserved. */
};
#pragma keylist oscc_brake_report_msg header.src_guid, sensor_descriptor.id
#pragma expose oscc_brake_report_msg


/**
 * @brief Brake command message.
 *
 */
struct oscc_brake_command_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_guid dest_guid; /*!< Destination GUID.
                        * Value \ref PSYNC_GUID_INVALID means not used. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp associated with the control command.
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. [microseconds] */
    double brake_position; /*!< Desired brake pedal position (normalized). [0.0, 1.0] */
};
#pragma keylist oscc_brake_command_msg header.src_guid dest_guid
#pragma expose oscc_brake_command_msg


/**
 * @brief Steering report message.
 *
 */
struct oscc_steering_report_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp.
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. [microseconds] */
    octet magic[2]; /*!< Magic number identifying CAN frame as from OSCC.
                     * Byte 0 should be \ref OSCC_MAGIC_WORD_BYTE_0.
                     * Byte 1 should be \ref OSCC_MAGIC_WORD_BYTE_1. */
    octet enabled; /*!< Steering controls enabled state.
                      * Zero value means disabled (commands are ignored).
                      * Non-zero value means enabled (no timeouts or overrides
                      * have occured). */
    octet operator_override; /*!< Driver override state.
                                * Zero value means there has been no operator
                                * override. Non-zero value means an operator
                                * has physically overridden the system. */
    octet dtcs; /*!< Bitfield of DTCs present in the module. */
    octet reserved[3]; /*!< Reserved. */
};
#pragma keylist oscc_steering_report_msg header.src_guid, sensor_descriptor.id
#pragma expose oscc_steering_report_msg


/**
 * @brief Steering command message.
 *
 */
struct oscc_steering_command_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_guid dest_guid; /*!< Destination GUID.
                        * Value \ref PSYNC_GUID_INVALID means not used. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp associated with the control command.
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. [microseconds] */
    double steering_torque; /*!< Desired steering wheel torque (normalized). [-1.0, 1.0] */
};
#pragma keylist oscc_steering_command_msg header.src_guid dest_guid
#pragma expose oscc_steering_command_msg


/**
 * @brief Throttle report message.
 *
 */
struct oscc_throttle_report_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp.
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. [microseconds] */
    octet magic[2]; /*!< Magic number identifying CAN frame as from OSCC.
                     * Byte 0 should be \ref OSCC_MAGIC_WORD_BYTE_0.
                     * Byte 1 should be \ref OSCC_MAGIC_WORD_BYTE_1. */
    octet enabled; /*!< Throttle controls enabled state.
                      * Zero value means disabled (commands are ignored).
                      * Non-zero value means enabled (no timeouts or overrides
                      * have occured). */
    octet operator_override; /*!< Driver override state.
                                * Zero value means there has been no operator
                                * override. Non-zero value means an operator
                                * has physically overridden the system. */
    octet dtcs; /*!< Bitfield of DTCs present in the module. */
    octet reserved[3]; /*!< Reserved. */
};
#pragma keylist oscc_throttle_report_msg header.src_guid, sensor_descriptor.id
#pragma expose oscc_throttle_report_msg


/**
 * @brief Throttle command message.
 *
 */
struct oscc_throttle_command_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_guid dest_guid; /*!< Destination GUID.
                        * Value \ref PSYNC_GUID_INVALID means not used. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp associated with the control command.
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. [microseconds] */
    double throttle_position; /*!< Desired throttle pedal position (normalized). [0.0, 1.0] */
};
#pragma keylist oscc_throttle_command_msg header.src_guid dest_guid
#pragma expose oscc_throttle_command_msg


/**
 * @brief Fault report message.
 *
 */
struct oscc_fault_report_msg
{
    ps_msg_header header; /*!< PolySync message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp.
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. [microseconds] */
    octet magic[2]; /*!< Magic number identifying CAN frame as from OSCC.
                     * Byte 0 should be \ref OSCC_MAGIC_WORD_BYTE_0.
                     * Byte 1 should be \ref OSCC_MAGIC_WORD_BYTE_1. */
    oscc_fault_origin_id fault_origin_id; /*!< Origin of the fault. */
    octet dtcs; /*!< DTC bitfield of the module that is sending out the fault. */
    octet reserved; /*!< Reserved. */
};
#pragma keylist oscc_fault_report_msg header.src_guid, sensor_descriptor.id
#pragma expose oscc_fault_report_msg


/**
 * @brief OSCC OBD CAN frame message.
 *
 */
struct oscc_obd_can_frame_msg
{
    ps_msg_header header; /*!< Message header. */
    ps_sensor_descriptor sensor_descriptor; /*!< Sensor descriptor. */
    ps_timestamp rx_timestamp; /*!< Receive timestamp.
                                * PolySync drivers will use
                                * the now time domain during
                                * record mode, or the replay time
                                * domain during replay mode. [microseconds] */
    unsigned long can_id; /*!< CAN_ID + EFF/RTR/ERR flag. */
    octet can_dlc; /*!< Frame payload length (0 .. CAN_MAX_DLEN). [bytes] */
    octet data[8]; /*!< Data buffer. */
};
#pragma keylist oscc_obd_can_frame_msg header.src_guid, sensor_descriptor.id
#pragma expose oscc_obd_can_frame_msg
